/*
Copyright 2020 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

type BackendObservation struct {
}

type BackendParameters struct {

	// +kubebuilder:validation:Required
	Address string `json:"address" tf:"address"`

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled"`

	// +kubebuilder:validation:Required
	HTTPPort int64 `json:"httpPort" tf:"http_port"`

	// +kubebuilder:validation:Required
	HTTPSPort int64 `json:"httpsPort" tf:"https_port"`

	// +kubebuilder:validation:Required
	HostHeader string `json:"hostHeader" tf:"host_header"`

	// +kubebuilder:validation:Optional
	Priority *int64 `json:"priority,omitempty" tf:"priority"`

	// +kubebuilder:validation:Optional
	Weight *int64 `json:"weight,omitempty" tf:"weight"`
}

type BackendPoolHealthProbeObservation struct {
	ID string `json:"id,omitempty" tf:"id"`
}

type BackendPoolHealthProbeParameters struct {

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled"`

	// +kubebuilder:validation:Optional
	IntervalInSeconds *int64 `json:"intervalInSeconds,omitempty" tf:"interval_in_seconds"`

	// +kubebuilder:validation:Required
	Name string `json:"name" tf:"name"`

	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path"`

	// +kubebuilder:validation:Optional
	ProbeMethod *string `json:"probeMethod,omitempty" tf:"probe_method"`

	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol,omitempty" tf:"protocol"`
}

type BackendPoolLoadBalancingObservation struct {
	ID string `json:"id,omitempty" tf:"id"`
}

type BackendPoolLoadBalancingParameters struct {

	// +kubebuilder:validation:Optional
	AdditionalLatencyMilliseconds *int64 `json:"additionalLatencyMilliseconds,omitempty" tf:"additional_latency_milliseconds"`

	// +kubebuilder:validation:Required
	Name string `json:"name" tf:"name"`

	// +kubebuilder:validation:Optional
	SampleSize *int64 `json:"sampleSize,omitempty" tf:"sample_size"`

	// +kubebuilder:validation:Optional
	SuccessfulSamplesRequired *int64 `json:"successfulSamplesRequired,omitempty" tf:"successful_samples_required"`
}

type BackendPoolObservation struct {
	ID string `json:"id,omitempty" tf:"id"`
}

type BackendPoolParameters struct {

	// +kubebuilder:validation:Required
	Backend []BackendParameters `json:"backend" tf:"backend"`

	// +kubebuilder:validation:Required
	HealthProbeName string `json:"healthProbeName" tf:"health_probe_name"`

	// +kubebuilder:validation:Required
	LoadBalancingName string `json:"loadBalancingName" tf:"load_balancing_name"`

	// +kubebuilder:validation:Required
	Name string `json:"name" tf:"name"`
}

type ExplicitResourceOrderObservation struct {
	BackendPoolHealthProbeIds []string `json:"backendPoolHealthProbeIds,omitempty" tf:"backend_pool_health_probe_ids"`

	BackendPoolIds []string `json:"backendPoolIds,omitempty" tf:"backend_pool_ids"`

	BackendPoolLoadBalancingIds []string `json:"backendPoolLoadBalancingIds,omitempty" tf:"backend_pool_load_balancing_ids"`

	FrontendEndpointIds []string `json:"frontendEndpointIds,omitempty" tf:"frontend_endpoint_ids"`

	RoutingRuleIds []string `json:"routingRuleIds,omitempty" tf:"routing_rule_ids"`
}

type ExplicitResourceOrderParameters struct {
}

type ForwardingConfigurationObservation struct {
}

type ForwardingConfigurationParameters struct {

	// +kubebuilder:validation:Required
	BackendPoolName string `json:"backendPoolName" tf:"backend_pool_name"`

	// +kubebuilder:validation:Optional
	CacheDuration *string `json:"cacheDuration,omitempty" tf:"cache_duration"`

	// +kubebuilder:validation:Optional
	CacheEnabled *bool `json:"cacheEnabled,omitempty" tf:"cache_enabled"`

	// +kubebuilder:validation:Optional
	CacheQueryParameterStripDirective *string `json:"cacheQueryParameterStripDirective,omitempty" tf:"cache_query_parameter_strip_directive"`

	// +kubebuilder:validation:Optional
	CacheQueryParameters []string `json:"cacheQueryParameters,omitempty" tf:"cache_query_parameters"`

	// +kubebuilder:validation:Optional
	CacheUseDynamicCompression *bool `json:"cacheUseDynamicCompression,omitempty" tf:"cache_use_dynamic_compression"`

	// +kubebuilder:validation:Optional
	CustomForwardingPath *string `json:"customForwardingPath,omitempty" tf:"custom_forwarding_path"`

	// +kubebuilder:validation:Optional
	ForwardingProtocol *string `json:"forwardingProtocol,omitempty" tf:"forwarding_protocol"`
}

type FrontdoorObservation struct {
	BackendPoolHealthProbes map[string]string `json:"backendPoolHealthProbes,omitempty" tf:"backend_pool_health_probes"`

	BackendPoolLoadBalancingSettings map[string]string `json:"backendPoolLoadBalancingSettings,omitempty" tf:"backend_pool_load_balancing_settings"`

	BackendPools map[string]string `json:"backendPools,omitempty" tf:"backend_pools"`

	Cname string `json:"cname,omitempty" tf:"cname"`

	ExplicitResourceOrder []ExplicitResourceOrderObservation `json:"explicitResourceOrder,omitempty" tf:"explicit_resource_order"`

	FrontendEndpoints map[string]string `json:"frontendEndpoints,omitempty" tf:"frontend_endpoints"`

	HeaderFrontdoorID string `json:"headerFrontdoorId,omitempty" tf:"header_frontdoor_id"`

	RoutingRules map[string]string `json:"routingRules,omitempty" tf:"routing_rules"`
}

type FrontdoorParameters struct {

	// +kubebuilder:validation:Required
	BackendPool []BackendPoolParameters `json:"backendPool" tf:"backend_pool"`

	// +kubebuilder:validation:Required
	BackendPoolHealthProbe []BackendPoolHealthProbeParameters `json:"backendPoolHealthProbe" tf:"backend_pool_health_probe"`

	// +kubebuilder:validation:Required
	BackendPoolLoadBalancing []BackendPoolLoadBalancingParameters `json:"backendPoolLoadBalancing" tf:"backend_pool_load_balancing"`

	// +kubebuilder:validation:Optional
	BackendPoolsSendReceiveTimeoutSeconds *int64 `json:"backendPoolsSendReceiveTimeoutSeconds,omitempty" tf:"backend_pools_send_receive_timeout_seconds"`

	// +kubebuilder:validation:Required
	EnforceBackendPoolsCertificateNameCheck bool `json:"enforceBackendPoolsCertificateNameCheck" tf:"enforce_backend_pools_certificate_name_check"`

	// +kubebuilder:validation:Optional
	FriendlyName *string `json:"friendlyName,omitempty" tf:"friendly_name"`

	// +kubebuilder:validation:Required
	FrontendEndpoint []FrontendEndpointParameters `json:"frontendEndpoint" tf:"frontend_endpoint"`

	// +kubebuilder:validation:Optional
	LoadBalancerEnabled *bool `json:"loadBalancerEnabled,omitempty" tf:"load_balancer_enabled"`

	// +kubebuilder:validation:Optional
	Location *string `json:"location,omitempty" tf:"location"`

	// +kubebuilder:validation:Required
	Name string `json:"name" tf:"name"`

	// +kubebuilder:validation:Required
	ResourceGroupName string `json:"resourceGroupName" tf:"resource_group_name"`

	// +kubebuilder:validation:Required
	RoutingRule []RoutingRuleParameters `json:"routingRule" tf:"routing_rule"`

	// +kubebuilder:validation:Optional
	Tags map[string]string `json:"tags,omitempty" tf:"tags"`
}

type FrontendEndpointObservation struct {
	ID string `json:"id,omitempty" tf:"id"`
}

type FrontendEndpointParameters struct {

	// +kubebuilder:validation:Required
	HostName string `json:"hostName" tf:"host_name"`

	// +kubebuilder:validation:Required
	Name string `json:"name" tf:"name"`

	// +kubebuilder:validation:Optional
	SessionAffinityEnabled *bool `json:"sessionAffinityEnabled,omitempty" tf:"session_affinity_enabled"`

	// +kubebuilder:validation:Optional
	SessionAffinityTTLSeconds *int64 `json:"sessionAffinityTtlSeconds,omitempty" tf:"session_affinity_ttl_seconds"`

	// +kubebuilder:validation:Optional
	WebApplicationFirewallPolicyLinkID *string `json:"webApplicationFirewallPolicyLinkId,omitempty" tf:"web_application_firewall_policy_link_id"`
}

type RedirectConfigurationObservation struct {
}

type RedirectConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	CustomFragment *string `json:"customFragment,omitempty" tf:"custom_fragment"`

	// +kubebuilder:validation:Optional
	CustomHost *string `json:"customHost,omitempty" tf:"custom_host"`

	// +kubebuilder:validation:Optional
	CustomPath *string `json:"customPath,omitempty" tf:"custom_path"`

	// +kubebuilder:validation:Optional
	CustomQueryString *string `json:"customQueryString,omitempty" tf:"custom_query_string"`

	// +kubebuilder:validation:Required
	RedirectProtocol string `json:"redirectProtocol" tf:"redirect_protocol"`

	// +kubebuilder:validation:Required
	RedirectType string `json:"redirectType" tf:"redirect_type"`
}

type RoutingRuleObservation struct {
	ID string `json:"id,omitempty" tf:"id"`
}

type RoutingRuleParameters struct {

	// +kubebuilder:validation:Required
	AcceptedProtocols []string `json:"acceptedProtocols" tf:"accepted_protocols"`

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled"`

	// +kubebuilder:validation:Optional
	ForwardingConfiguration []ForwardingConfigurationParameters `json:"forwardingConfiguration,omitempty" tf:"forwarding_configuration"`

	// +kubebuilder:validation:Required
	FrontendEndpoints []string `json:"frontendEndpoints" tf:"frontend_endpoints"`

	// +kubebuilder:validation:Required
	Name string `json:"name" tf:"name"`

	// +kubebuilder:validation:Required
	PatternsToMatch []string `json:"patternsToMatch" tf:"patterns_to_match"`

	// +kubebuilder:validation:Optional
	RedirectConfiguration []RedirectConfigurationParameters `json:"redirectConfiguration,omitempty" tf:"redirect_configuration"`
}

// FrontdoorSpec defines the desired state of Frontdoor
type FrontdoorSpec struct {
	xpv1.ResourceSpec `json:",inline"`
	ForProvider       FrontdoorParameters `json:"forProvider"`
}

// FrontdoorStatus defines the observed state of Frontdoor.
type FrontdoorStatus struct {
	xpv1.ResourceStatus `json:",inline"`
	AtProvider          FrontdoorObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Frontdoor is the Schema for the Frontdoors API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,azure}
type Frontdoor struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              FrontdoorSpec   `json:"spec"`
	Status            FrontdoorStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// FrontdoorList contains a list of Frontdoors
type FrontdoorList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Frontdoor `json:"items"`
}

// Repository type metadata.
var (
	FrontdoorKind             = "Frontdoor"
	FrontdoorGroupKind        = schema.GroupKind{Group: Group, Kind: FrontdoorKind}.String()
	FrontdoorKindAPIVersion   = FrontdoorKind + "." + GroupVersion.String()
	FrontdoorGroupVersionKind = GroupVersion.WithKind(FrontdoorKind)
)

func init() {
	SchemeBuilder.Register(&Frontdoor{}, &FrontdoorList{})
}
