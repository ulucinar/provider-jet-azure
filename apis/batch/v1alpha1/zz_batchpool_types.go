/*
Copyright 2020 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

type AutoScaleObservation struct {
}

type AutoScaleParameters struct {

	// +kubebuilder:validation:Optional
	EvaluationInterval *string `json:"evaluationInterval,omitempty" tf:"evaluation_interval"`

	// +kubebuilder:validation:Required
	Formula string `json:"formula" tf:"formula"`
}

type AutoUserObservation struct {
}

type AutoUserParameters struct {

	// +kubebuilder:validation:Optional
	ElevationLevel *string `json:"elevationLevel,omitempty" tf:"elevation_level"`

	// +kubebuilder:validation:Optional
	Scope *string `json:"scope,omitempty" tf:"scope"`
}

type BatchPoolObservation struct {
}

type BatchPoolParameters struct {

	// +kubebuilder:validation:Required
	AccountName string `json:"accountName" tf:"account_name"`

	// +kubebuilder:validation:Optional
	AutoScale []AutoScaleParameters `json:"autoScale,omitempty" tf:"auto_scale"`

	// +kubebuilder:validation:Optional
	Certificate []CertificateParameters `json:"certificate,omitempty" tf:"certificate"`

	// +kubebuilder:validation:Optional
	ContainerConfiguration []ContainerConfigurationParameters `json:"containerConfiguration,omitempty" tf:"container_configuration"`

	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name"`

	// +kubebuilder:validation:Optional
	FixedScale []FixedScaleParameters `json:"fixedScale,omitempty" tf:"fixed_scale"`

	// +kubebuilder:validation:Optional
	MaxTasksPerNode *int64 `json:"maxTasksPerNode,omitempty" tf:"max_tasks_per_node"`

	// +kubebuilder:validation:Optional
	Metadata map[string]string `json:"metadata,omitempty" tf:"metadata"`

	// +kubebuilder:validation:Required
	Name string `json:"name" tf:"name"`

	// +kubebuilder:validation:Optional
	NetworkConfiguration []NetworkConfigurationParameters `json:"networkConfiguration,omitempty" tf:"network_configuration"`

	// +kubebuilder:validation:Required
	NodeAgentSkuID string `json:"nodeAgentSkuId" tf:"node_agent_sku_id"`

	// +kubebuilder:validation:Required
	ResourceGroupName string `json:"resourceGroupName" tf:"resource_group_name"`

	// +kubebuilder:validation:Optional
	StartTask []StartTaskParameters `json:"startTask,omitempty" tf:"start_task"`

	// +kubebuilder:validation:Optional
	StopPendingResizeOperation *bool `json:"stopPendingResizeOperation,omitempty" tf:"stop_pending_resize_operation"`

	// +kubebuilder:validation:Required
	StorageImageReference []StorageImageReferenceParameters `json:"storageImageReference" tf:"storage_image_reference"`

	// +kubebuilder:validation:Required
	VMSize string `json:"vmSize" tf:"vm_size"`
}

type CertificateObservation struct {
}

type CertificateParameters struct {

	// +kubebuilder:validation:Required
	ID string `json:"id" tf:"id"`

	// +kubebuilder:validation:Required
	StoreLocation string `json:"storeLocation" tf:"store_location"`

	// +kubebuilder:validation:Optional
	StoreName *string `json:"storeName,omitempty" tf:"store_name"`

	// +kubebuilder:validation:Optional
	Visibility []string `json:"visibility,omitempty" tf:"visibility"`
}

type ContainerConfigurationObservation struct {
}

type ContainerConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	ContainerImageNames []string `json:"containerImageNames,omitempty" tf:"container_image_names"`

	// +kubebuilder:validation:Optional
	ContainerRegistries []ContainerRegistriesParameters `json:"containerRegistries,omitempty" tf:"container_registries"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type"`
}

type ContainerRegistriesObservation struct {
}

type ContainerRegistriesParameters struct {

	// +kubebuilder:validation:Required
	Password string `json:"password" tf:"password"`

	// +kubebuilder:validation:Required
	RegistryServer string `json:"registryServer" tf:"registry_server"`

	// +kubebuilder:validation:Required
	UserName string `json:"userName" tf:"user_name"`
}

type EndpointConfigurationObservation struct {
}

type EndpointConfigurationParameters struct {

	// +kubebuilder:validation:Required
	BackendPort int64 `json:"backendPort" tf:"backend_port"`

	// +kubebuilder:validation:Required
	FrontendPortRange string `json:"frontendPortRange" tf:"frontend_port_range"`

	// +kubebuilder:validation:Required
	Name string `json:"name" tf:"name"`

	// +kubebuilder:validation:Optional
	NetworkSecurityGroupRules []NetworkSecurityGroupRulesParameters `json:"networkSecurityGroupRules,omitempty" tf:"network_security_group_rules"`

	// +kubebuilder:validation:Required
	Protocol string `json:"protocol" tf:"protocol"`
}

type FixedScaleObservation struct {
}

type FixedScaleParameters struct {

	// +kubebuilder:validation:Optional
	ResizeTimeout *string `json:"resizeTimeout,omitempty" tf:"resize_timeout"`

	// +kubebuilder:validation:Optional
	TargetDedicatedNodes *int64 `json:"targetDedicatedNodes,omitempty" tf:"target_dedicated_nodes"`

	// +kubebuilder:validation:Optional
	TargetLowPriorityNodes *int64 `json:"targetLowPriorityNodes,omitempty" tf:"target_low_priority_nodes"`
}

type NetworkConfigurationObservation struct {
}

type NetworkConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	EndpointConfiguration []EndpointConfigurationParameters `json:"endpointConfiguration,omitempty" tf:"endpoint_configuration"`

	// +kubebuilder:validation:Optional
	PublicAddressProvisioningType *string `json:"publicAddressProvisioningType,omitempty" tf:"public_address_provisioning_type"`

	// +kubebuilder:validation:Optional
	PublicIps []string `json:"publicIps,omitempty" tf:"public_ips"`

	// +kubebuilder:validation:Required
	SubnetID string `json:"subnetId" tf:"subnet_id"`
}

type NetworkSecurityGroupRulesObservation struct {
}

type NetworkSecurityGroupRulesParameters struct {

	// +kubebuilder:validation:Required
	Access string `json:"access" tf:"access"`

	// +kubebuilder:validation:Required
	Priority int64 `json:"priority" tf:"priority"`

	// +kubebuilder:validation:Required
	SourceAddressPrefix string `json:"sourceAddressPrefix" tf:"source_address_prefix"`
}

type ResourceFileObservation struct {
}

type ResourceFileParameters struct {

	// +kubebuilder:validation:Optional
	AutoStorageContainerName *string `json:"autoStorageContainerName,omitempty" tf:"auto_storage_container_name"`

	// +kubebuilder:validation:Optional
	BlobPrefix *string `json:"blobPrefix,omitempty" tf:"blob_prefix"`

	// +kubebuilder:validation:Optional
	FileMode *string `json:"fileMode,omitempty" tf:"file_mode"`

	// +kubebuilder:validation:Optional
	FilePath *string `json:"filePath,omitempty" tf:"file_path"`

	// +kubebuilder:validation:Optional
	HTTPURL *string `json:"httpUrl,omitempty" tf:"http_url"`

	// +kubebuilder:validation:Optional
	StorageContainerURL *string `json:"storageContainerUrl,omitempty" tf:"storage_container_url"`
}

type StartTaskObservation struct {
}

type StartTaskParameters struct {

	// +kubebuilder:validation:Required
	CommandLine string `json:"commandLine" tf:"command_line"`

	// +kubebuilder:validation:Optional
	Environment map[string]string `json:"environment,omitempty" tf:"environment"`

	// +kubebuilder:validation:Optional
	MaxTaskRetryCount *int64 `json:"maxTaskRetryCount,omitempty" tf:"max_task_retry_count"`

	// +kubebuilder:validation:Optional
	ResourceFile []ResourceFileParameters `json:"resourceFile,omitempty" tf:"resource_file"`

	// +kubebuilder:validation:Required
	UserIdentity []UserIdentityParameters `json:"userIdentity" tf:"user_identity"`

	// +kubebuilder:validation:Optional
	WaitForSuccess *bool `json:"waitForSuccess,omitempty" tf:"wait_for_success"`
}

type StorageImageReferenceObservation struct {
}

type StorageImageReferenceParameters struct {

	// +kubebuilder:validation:Optional
	ID *string `json:"id,omitempty" tf:"id"`

	// +kubebuilder:validation:Optional
	Offer *string `json:"offer,omitempty" tf:"offer"`

	// +kubebuilder:validation:Optional
	Publisher *string `json:"publisher,omitempty" tf:"publisher"`

	// +kubebuilder:validation:Optional
	Sku *string `json:"sku,omitempty" tf:"sku"`

	// +kubebuilder:validation:Optional
	Version *string `json:"version,omitempty" tf:"version"`
}

type UserIdentityObservation struct {
}

type UserIdentityParameters struct {

	// +kubebuilder:validation:Optional
	AutoUser []AutoUserParameters `json:"autoUser,omitempty" tf:"auto_user"`

	// +kubebuilder:validation:Optional
	UserName *string `json:"userName,omitempty" tf:"user_name"`
}

// BatchPoolSpec defines the desired state of BatchPool
type BatchPoolSpec struct {
	xpv1.ResourceSpec `json:",inline"`
	ForProvider       BatchPoolParameters `json:"forProvider"`
}

// BatchPoolStatus defines the observed state of BatchPool.
type BatchPoolStatus struct {
	xpv1.ResourceStatus `json:",inline"`
	AtProvider          BatchPoolObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// BatchPool is the Schema for the BatchPools API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,azure}
type BatchPool struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              BatchPoolSpec   `json:"spec"`
	Status            BatchPoolStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// BatchPoolList contains a list of BatchPools
type BatchPoolList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []BatchPool `json:"items"`
}

// Repository type metadata.
var (
	BatchPoolKind             = "BatchPool"
	BatchPoolGroupKind        = schema.GroupKind{Group: Group, Kind: BatchPoolKind}.String()
	BatchPoolKindAPIVersion   = BatchPoolKind + "." + GroupVersion.String()
	BatchPoolGroupVersionKind = GroupVersion.WithKind(BatchPoolKind)
)

func init() {
	SchemeBuilder.Register(&BatchPool{}, &BatchPoolList{})
}
