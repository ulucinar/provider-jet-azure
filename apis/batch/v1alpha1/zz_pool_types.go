/*
Copyright 2020 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AutoScaleObservation struct {
}

type AutoScaleParameters struct {

	// +kubebuilder:validation:Optional
	EvaluationInterval *string `json:"evaluationInterval,omitempty" tf:"evaluation_interval,omitempty"`

	// +kubebuilder:validation:Required
	Formula *string `json:"formula" tf:"formula,omitempty"`
}

type AutoUserObservation struct {
}

type AutoUserParameters struct {

	// +kubebuilder:validation:Optional
	ElevationLevel *string `json:"elevationLevel,omitempty" tf:"elevation_level,omitempty"`

	// +kubebuilder:validation:Optional
	Scope *string `json:"scope,omitempty" tf:"scope,omitempty"`
}

type ContainerConfigurationObservation struct {
}

type ContainerConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	ContainerImageNames []*string `json:"containerImageNames,omitempty" tf:"container_image_names,omitempty"`

	// +kubebuilder:validation:Optional
	ContainerRegistries []ContainerRegistriesParameters `json:"containerRegistries,omitempty" tf:"container_registries,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type ContainerRegistriesObservation struct {
}

type ContainerRegistriesParameters struct {

	// +kubebuilder:validation:Required
	PasswordSecretRef v1.SecretKeySelector `json:"passwordSecretRef" tf:"-"`

	// +kubebuilder:validation:Required
	RegistryServer *string `json:"registryServer" tf:"registry_server,omitempty"`

	// +kubebuilder:validation:Required
	UserName *string `json:"userName" tf:"user_name,omitempty"`
}

type EndpointConfigurationObservation struct {
}

type EndpointConfigurationParameters struct {

	// +kubebuilder:validation:Required
	BackendPort *int64 `json:"backendPort" tf:"backend_port,omitempty"`

	// +kubebuilder:validation:Required
	FrontendPortRange *string `json:"frontendPortRange" tf:"frontend_port_range,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	NetworkSecurityGroupRules []NetworkSecurityGroupRulesParameters `json:"networkSecurityGroupRules,omitempty" tf:"network_security_group_rules,omitempty"`

	// +kubebuilder:validation:Required
	Protocol *string `json:"protocol" tf:"protocol,omitempty"`
}

type FixedScaleObservation struct {
}

type FixedScaleParameters struct {

	// +kubebuilder:validation:Optional
	ResizeTimeout *string `json:"resizeTimeout,omitempty" tf:"resize_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	TargetDedicatedNodes *int64 `json:"targetDedicatedNodes,omitempty" tf:"target_dedicated_nodes,omitempty"`

	// +kubebuilder:validation:Optional
	TargetLowPriorityNodes *int64 `json:"targetLowPriorityNodes,omitempty" tf:"target_low_priority_nodes,omitempty"`
}

type NetworkConfigurationObservation struct {
}

type NetworkConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	EndpointConfiguration []EndpointConfigurationParameters `json:"endpointConfiguration,omitempty" tf:"endpoint_configuration,omitempty"`

	// +kubebuilder:validation:Optional
	PublicAddressProvisioningType *string `json:"publicAddressProvisioningType,omitempty" tf:"public_address_provisioning_type,omitempty"`

	// +kubebuilder:validation:Optional
	PublicIps []*string `json:"publicIps,omitempty" tf:"public_ips,omitempty"`

	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-jet-azure/apis/network/v1alpha2.Subnet
	// +crossplane:generate:reference:extractor=github.com/crossplane-contrib/provider-jet-azure/apis/rconfig.ExtractResourceID()
	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetIDRef *v1.Reference `json:"subnetIdRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	SubnetIDSelector *v1.Selector `json:"subnetIdSelector,omitempty" tf:"-"`
}

type NetworkSecurityGroupRulesObservation struct {
}

type NetworkSecurityGroupRulesParameters struct {

	// +kubebuilder:validation:Required
	Access *string `json:"access" tf:"access,omitempty"`

	// +kubebuilder:validation:Required
	Priority *int64 `json:"priority" tf:"priority,omitempty"`

	// +kubebuilder:validation:Required
	SourceAddressPrefix *string `json:"sourceAddressPrefix" tf:"source_address_prefix,omitempty"`
}

type PoolCertificateObservation struct {
}

type PoolCertificateParameters struct {

	// +kubebuilder:validation:Required
	ID *string `json:"id" tf:"id,omitempty"`

	// +kubebuilder:validation:Required
	StoreLocation *string `json:"storeLocation" tf:"store_location,omitempty"`

	// +kubebuilder:validation:Optional
	StoreName *string `json:"storeName,omitempty" tf:"store_name,omitempty"`

	// +kubebuilder:validation:Optional
	Visibility []*string `json:"visibility,omitempty" tf:"visibility,omitempty"`
}

type PoolObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type PoolParameters struct {

	// +kubebuilder:validation:Required
	AccountName *string `json:"accountName" tf:"account_name,omitempty"`

	// +kubebuilder:validation:Optional
	AutoScale []AutoScaleParameters `json:"autoScale,omitempty" tf:"auto_scale,omitempty"`

	// +kubebuilder:validation:Optional
	Certificate []PoolCertificateParameters `json:"certificate,omitempty" tf:"certificate,omitempty"`

	// +kubebuilder:validation:Optional
	ContainerConfiguration []ContainerConfigurationParameters `json:"containerConfiguration,omitempty" tf:"container_configuration,omitempty"`

	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// +kubebuilder:validation:Optional
	FixedScale []FixedScaleParameters `json:"fixedScale,omitempty" tf:"fixed_scale,omitempty"`

	// +kubebuilder:validation:Optional
	MaxTasksPerNode *int64 `json:"maxTasksPerNode,omitempty" tf:"max_tasks_per_node,omitempty"`

	// +kubebuilder:validation:Optional
	Metadata map[string]*string `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	NetworkConfiguration []NetworkConfigurationParameters `json:"networkConfiguration,omitempty" tf:"network_configuration,omitempty"`

	// +kubebuilder:validation:Required
	NodeAgentSkuID *string `json:"nodeAgentSkuId" tf:"node_agent_sku_id,omitempty"`

	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-jet-azure/apis/azure2/v1alpha2.ResourceGroup
	// +kubebuilder:validation:Optional
	ResourceGroupName *string `json:"resourceGroupName,omitempty" tf:"resource_group_name,omitempty"`

	// +kubebuilder:validation:Optional
	ResourceGroupNameRef *v1.Reference `json:"resourceGroupNameRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ResourceGroupNameSelector *v1.Selector `json:"resourceGroupNameSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	StartTask []StartTaskParameters `json:"startTask,omitempty" tf:"start_task,omitempty"`

	// +kubebuilder:validation:Optional
	StopPendingResizeOperation *bool `json:"stopPendingResizeOperation,omitempty" tf:"stop_pending_resize_operation,omitempty"`

	// +kubebuilder:validation:Required
	StorageImageReference []StorageImageReferenceParameters `json:"storageImageReference" tf:"storage_image_reference,omitempty"`

	// +kubebuilder:validation:Required
	VMSize *string `json:"vmSize" tf:"vm_size,omitempty"`
}

type ResourceFileObservation struct {
}

type ResourceFileParameters struct {

	// +kubebuilder:validation:Optional
	AutoStorageContainerName *string `json:"autoStorageContainerName,omitempty" tf:"auto_storage_container_name,omitempty"`

	// +kubebuilder:validation:Optional
	BlobPrefix *string `json:"blobPrefix,omitempty" tf:"blob_prefix,omitempty"`

	// +kubebuilder:validation:Optional
	FileMode *string `json:"fileMode,omitempty" tf:"file_mode,omitempty"`

	// +kubebuilder:validation:Optional
	FilePath *string `json:"filePath,omitempty" tf:"file_path,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPURL *string `json:"httpUrl,omitempty" tf:"http_url,omitempty"`

	// +kubebuilder:validation:Optional
	StorageContainerURL *string `json:"storageContainerUrl,omitempty" tf:"storage_container_url,omitempty"`
}

type StartTaskObservation struct {
}

type StartTaskParameters struct {

	// +kubebuilder:validation:Required
	CommandLine *string `json:"commandLine" tf:"command_line,omitempty"`

	// +kubebuilder:validation:Optional
	Environment map[string]*string `json:"environment,omitempty" tf:"environment,omitempty"`

	// +kubebuilder:validation:Optional
	MaxTaskRetryCount *int64 `json:"maxTaskRetryCount,omitempty" tf:"max_task_retry_count,omitempty"`

	// +kubebuilder:validation:Optional
	ResourceFile []ResourceFileParameters `json:"resourceFile,omitempty" tf:"resource_file,omitempty"`

	// +kubebuilder:validation:Required
	UserIdentity []UserIdentityParameters `json:"userIdentity" tf:"user_identity,omitempty"`

	// +kubebuilder:validation:Optional
	WaitForSuccess *bool `json:"waitForSuccess,omitempty" tf:"wait_for_success,omitempty"`
}

type StorageImageReferenceObservation struct {
}

type StorageImageReferenceParameters struct {

	// +kubebuilder:validation:Optional
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// +kubebuilder:validation:Optional
	Offer *string `json:"offer,omitempty" tf:"offer,omitempty"`

	// +kubebuilder:validation:Optional
	Publisher *string `json:"publisher,omitempty" tf:"publisher,omitempty"`

	// +kubebuilder:validation:Optional
	Sku *string `json:"sku,omitempty" tf:"sku,omitempty"`

	// +kubebuilder:validation:Optional
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type UserIdentityObservation struct {
}

type UserIdentityParameters struct {

	// +kubebuilder:validation:Optional
	AutoUser []AutoUserParameters `json:"autoUser,omitempty" tf:"auto_user,omitempty"`

	// +kubebuilder:validation:Optional
	UserName *string `json:"userName,omitempty" tf:"user_name,omitempty"`
}

// PoolSpec defines the desired state of Pool
type PoolSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     PoolParameters `json:"forProvider"`
}

// PoolStatus defines the observed state of Pool.
type PoolStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        PoolObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Pool is the Schema for the Pools API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,azurejet}
type Pool struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              PoolSpec   `json:"spec"`
	Status            PoolStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// PoolList contains a list of Pools
type PoolList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Pool `json:"items"`
}

// Repository type metadata.
var (
	Pool_Kind             = "Pool"
	Pool_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Pool_Kind}.String()
	Pool_KindAPIVersion   = Pool_Kind + "." + CRDGroupVersion.String()
	Pool_GroupVersionKind = CRDGroupVersion.WithKind(Pool_Kind)
)

func init() {
	SchemeBuilder.Register(&Pool{}, &PoolList{})
}
