/*
Copyright 2020 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

type CatalogInfoObservation struct {
}

type CatalogInfoParameters struct {

	// +kubebuilder:validation:Optional
	AdministratorLogin *string `json:"administratorLogin,omitempty" tf:"administrator_login"`

	// +kubebuilder:validation:Optional
	AdministratorPassword *string `json:"administratorPassword,omitempty" tf:"administrator_password"`

	// +kubebuilder:validation:Optional
	DualStandbyPairName *string `json:"dualStandbyPairName,omitempty" tf:"dual_standby_pair_name"`

	// +kubebuilder:validation:Optional
	PricingTier *string `json:"pricingTier,omitempty" tf:"pricing_tier"`

	// +kubebuilder:validation:Required
	ServerEndpoint string `json:"serverEndpoint" tf:"server_endpoint"`
}

type CommandKeyObservation struct {
}

type CommandKeyParameters struct {

	// +kubebuilder:validation:Optional
	KeyVaultPassword []KeyVaultPasswordParameters `json:"keyVaultPassword,omitempty" tf:"key_vault_password"`

	// +kubebuilder:validation:Optional
	Password *string `json:"password,omitempty" tf:"password"`

	// +kubebuilder:validation:Required
	TargetName string `json:"targetName" tf:"target_name"`

	// +kubebuilder:validation:Required
	UserName string `json:"userName" tf:"user_name"`
}

type ComponentObservation struct {
}

type ComponentParameters struct {

	// +kubebuilder:validation:Optional
	KeyVaultLicense []KeyVaultLicenseParameters `json:"keyVaultLicense,omitempty" tf:"key_vault_license"`

	// +kubebuilder:validation:Optional
	License *string `json:"license,omitempty" tf:"license"`

	// +kubebuilder:validation:Required
	Name string `json:"name" tf:"name"`
}

type CustomSetupScriptObservation struct {
}

type CustomSetupScriptParameters struct {

	// +kubebuilder:validation:Required
	BlobContainerURI string `json:"blobContainerUri" tf:"blob_container_uri"`

	// +kubebuilder:validation:Required
	SasToken string `json:"sasToken" tf:"sas_token"`
}

type DataFactoryIntegrationRuntimeAzureSsisObservation struct {
}

type DataFactoryIntegrationRuntimeAzureSsisParameters struct {

	// +kubebuilder:validation:Optional
	CatalogInfo []CatalogInfoParameters `json:"catalogInfo,omitempty" tf:"catalog_info"`

	// +kubebuilder:validation:Optional
	CustomSetupScript []CustomSetupScriptParameters `json:"customSetupScript,omitempty" tf:"custom_setup_script"`

	// +kubebuilder:validation:Required
	DataFactoryName string `json:"dataFactoryName" tf:"data_factory_name"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description"`

	// +kubebuilder:validation:Optional
	Edition *string `json:"edition,omitempty" tf:"edition"`

	// +kubebuilder:validation:Optional
	ExpressCustomSetup []ExpressCustomSetupParameters `json:"expressCustomSetup,omitempty" tf:"express_custom_setup"`

	// +kubebuilder:validation:Optional
	LicenseType *string `json:"licenseType,omitempty" tf:"license_type"`

	// +kubebuilder:validation:Required
	Location string `json:"location" tf:"location"`

	// +kubebuilder:validation:Optional
	MaxParallelExecutionsPerNode *int64 `json:"maxParallelExecutionsPerNode,omitempty" tf:"max_parallel_executions_per_node"`

	// +kubebuilder:validation:Required
	Name string `json:"name" tf:"name"`

	// +kubebuilder:validation:Required
	NodeSize string `json:"nodeSize" tf:"node_size"`

	// +kubebuilder:validation:Optional
	NumberOfNodes *int64 `json:"numberOfNodes,omitempty" tf:"number_of_nodes"`

	// +kubebuilder:validation:Optional
	PackageStore []PackageStoreParameters `json:"packageStore,omitempty" tf:"package_store"`

	// +kubebuilder:validation:Optional
	Proxy []ProxyParameters `json:"proxy,omitempty" tf:"proxy"`

	// +kubebuilder:validation:Required
	ResourceGroupName string `json:"resourceGroupName" tf:"resource_group_name"`

	// +kubebuilder:validation:Optional
	VnetIntegration []VnetIntegrationParameters `json:"vnetIntegration,omitempty" tf:"vnet_integration"`
}

type ExpressCustomSetupObservation struct {
}

type ExpressCustomSetupParameters struct {

	// +kubebuilder:validation:Optional
	CommandKey []CommandKeyParameters `json:"commandKey,omitempty" tf:"command_key"`

	// +kubebuilder:validation:Optional
	Component []ComponentParameters `json:"component,omitempty" tf:"component"`

	// +kubebuilder:validation:Optional
	Environment map[string]string `json:"environment,omitempty" tf:"environment"`

	// +kubebuilder:validation:Optional
	PowershellVersion *string `json:"powershellVersion,omitempty" tf:"powershell_version"`
}

type KeyVaultLicenseObservation struct {
}

type KeyVaultLicenseParameters struct {

	// +kubebuilder:validation:Required
	LinkedServiceName string `json:"linkedServiceName" tf:"linked_service_name"`

	// +kubebuilder:validation:Optional
	Parameters map[string]string `json:"parameters,omitempty" tf:"parameters"`

	// +kubebuilder:validation:Required
	SecretName string `json:"secretName" tf:"secret_name"`

	// +kubebuilder:validation:Optional
	SecretVersion *string `json:"secretVersion,omitempty" tf:"secret_version"`
}

type KeyVaultPasswordObservation struct {
}

type KeyVaultPasswordParameters struct {

	// +kubebuilder:validation:Required
	LinkedServiceName string `json:"linkedServiceName" tf:"linked_service_name"`

	// +kubebuilder:validation:Optional
	Parameters map[string]string `json:"parameters,omitempty" tf:"parameters"`

	// +kubebuilder:validation:Required
	SecretName string `json:"secretName" tf:"secret_name"`

	// +kubebuilder:validation:Optional
	SecretVersion *string `json:"secretVersion,omitempty" tf:"secret_version"`
}

type PackageStoreObservation struct {
}

type PackageStoreParameters struct {

	// +kubebuilder:validation:Required
	LinkedServiceName string `json:"linkedServiceName" tf:"linked_service_name"`

	// +kubebuilder:validation:Required
	Name string `json:"name" tf:"name"`
}

type ProxyObservation struct {
}

type ProxyParameters struct {

	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path"`

	// +kubebuilder:validation:Required
	SelfHostedIntegrationRuntimeName string `json:"selfHostedIntegrationRuntimeName" tf:"self_hosted_integration_runtime_name"`

	// +kubebuilder:validation:Required
	StagingStorageLinkedServiceName string `json:"stagingStorageLinkedServiceName" tf:"staging_storage_linked_service_name"`
}

type VnetIntegrationObservation struct {
}

type VnetIntegrationParameters struct {

	// +kubebuilder:validation:Optional
	PublicIps []string `json:"publicIps,omitempty" tf:"public_ips"`

	// +kubebuilder:validation:Required
	SubnetName string `json:"subnetName" tf:"subnet_name"`

	// +kubebuilder:validation:Required
	VnetID string `json:"vnetId" tf:"vnet_id"`
}

// DataFactoryIntegrationRuntimeAzureSsisSpec defines the desired state of DataFactoryIntegrationRuntimeAzureSsis
type DataFactoryIntegrationRuntimeAzureSsisSpec struct {
	xpv1.ResourceSpec `json:",inline"`
	ForProvider       DataFactoryIntegrationRuntimeAzureSsisParameters `json:"forProvider"`
}

// DataFactoryIntegrationRuntimeAzureSsisStatus defines the observed state of DataFactoryIntegrationRuntimeAzureSsis.
type DataFactoryIntegrationRuntimeAzureSsisStatus struct {
	xpv1.ResourceStatus `json:",inline"`
	AtProvider          DataFactoryIntegrationRuntimeAzureSsisObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// DataFactoryIntegrationRuntimeAzureSsis is the Schema for the DataFactoryIntegrationRuntimeAzureSsiss API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,azure}
type DataFactoryIntegrationRuntimeAzureSsis struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              DataFactoryIntegrationRuntimeAzureSsisSpec   `json:"spec"`
	Status            DataFactoryIntegrationRuntimeAzureSsisStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// DataFactoryIntegrationRuntimeAzureSsisList contains a list of DataFactoryIntegrationRuntimeAzureSsiss
type DataFactoryIntegrationRuntimeAzureSsisList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []DataFactoryIntegrationRuntimeAzureSsis `json:"items"`
}

// Repository type metadata.
var (
	DataFactoryIntegrationRuntimeAzureSsisKind             = "DataFactoryIntegrationRuntimeAzureSsis"
	DataFactoryIntegrationRuntimeAzureSsisGroupKind        = schema.GroupKind{Group: Group, Kind: DataFactoryIntegrationRuntimeAzureSsisKind}.String()
	DataFactoryIntegrationRuntimeAzureSsisKindAPIVersion   = DataFactoryIntegrationRuntimeAzureSsisKind + "." + GroupVersion.String()
	DataFactoryIntegrationRuntimeAzureSsisGroupVersionKind = GroupVersion.WithKind(DataFactoryIntegrationRuntimeAzureSsisKind)
)

func init() {
	SchemeBuilder.Register(&DataFactoryIntegrationRuntimeAzureSsis{}, &DataFactoryIntegrationRuntimeAzureSsisList{})
}
