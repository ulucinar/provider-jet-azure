/*
Copyright 2020 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

type ApplicationInsightsWebTestLocationAvailabilityCriteriaObservation struct {
}

type ApplicationInsightsWebTestLocationAvailabilityCriteriaParameters struct {

	// +kubebuilder:validation:Required
	ComponentID string `json:"componentId" tf:"component_id"`

	// +kubebuilder:validation:Required
	FailedLocationCount int64 `json:"failedLocationCount" tf:"failed_location_count"`

	// +kubebuilder:validation:Required
	WebTestID string `json:"webTestId" tf:"web_test_id"`
}

type DimensionObservation struct {
}

type DimensionParameters struct {

	// +kubebuilder:validation:Required
	Name string `json:"name" tf:"name"`

	// +kubebuilder:validation:Required
	Operator string `json:"operator" tf:"operator"`

	// +kubebuilder:validation:Required
	Values []string `json:"values" tf:"values"`
}

type DynamicCriteriaDimensionObservation struct {
}

type DynamicCriteriaDimensionParameters struct {

	// +kubebuilder:validation:Required
	Name string `json:"name" tf:"name"`

	// +kubebuilder:validation:Required
	Operator string `json:"operator" tf:"operator"`

	// +kubebuilder:validation:Required
	Values []string `json:"values" tf:"values"`
}

type DynamicCriteriaObservation struct {
}

type DynamicCriteriaParameters struct {

	// +kubebuilder:validation:Required
	Aggregation string `json:"aggregation" tf:"aggregation"`

	// +kubebuilder:validation:Required
	AlertSensitivity string `json:"alertSensitivity" tf:"alert_sensitivity"`

	// +kubebuilder:validation:Optional
	Dimension []DynamicCriteriaDimensionParameters `json:"dimension,omitempty" tf:"dimension"`

	// +kubebuilder:validation:Optional
	EvaluationFailureCount *int64 `json:"evaluationFailureCount,omitempty" tf:"evaluation_failure_count"`

	// +kubebuilder:validation:Optional
	EvaluationTotalCount *int64 `json:"evaluationTotalCount,omitempty" tf:"evaluation_total_count"`

	// +kubebuilder:validation:Optional
	IgnoreDataBefore *string `json:"ignoreDataBefore,omitempty" tf:"ignore_data_before"`

	// +kubebuilder:validation:Required
	MetricName string `json:"metricName" tf:"metric_name"`

	// +kubebuilder:validation:Required
	MetricNamespace string `json:"metricNamespace" tf:"metric_namespace"`

	// +kubebuilder:validation:Required
	Operator string `json:"operator" tf:"operator"`

	// +kubebuilder:validation:Optional
	SkipMetricValidation *bool `json:"skipMetricValidation,omitempty" tf:"skip_metric_validation"`
}

type MonitorMetricAlertActionObservation struct {
}

type MonitorMetricAlertActionParameters struct {

	// +kubebuilder:validation:Required
	ActionGroupID string `json:"actionGroupId" tf:"action_group_id"`

	// +kubebuilder:validation:Optional
	WebhookProperties map[string]string `json:"webhookProperties,omitempty" tf:"webhook_properties"`
}

type MonitorMetricAlertCriteriaObservation struct {
}

type MonitorMetricAlertCriteriaParameters struct {

	// +kubebuilder:validation:Required
	Aggregation string `json:"aggregation" tf:"aggregation"`

	// +kubebuilder:validation:Optional
	Dimension []DimensionParameters `json:"dimension,omitempty" tf:"dimension"`

	// +kubebuilder:validation:Required
	MetricName string `json:"metricName" tf:"metric_name"`

	// +kubebuilder:validation:Required
	MetricNamespace string `json:"metricNamespace" tf:"metric_namespace"`

	// +kubebuilder:validation:Required
	Operator string `json:"operator" tf:"operator"`

	// +kubebuilder:validation:Optional
	SkipMetricValidation *bool `json:"skipMetricValidation,omitempty" tf:"skip_metric_validation"`

	// +kubebuilder:validation:Required
	Threshold float64 `json:"threshold" tf:"threshold"`
}

type MonitorMetricAlertObservation struct {
}

type MonitorMetricAlertParameters struct {

	// +kubebuilder:validation:Optional
	Action []MonitorMetricAlertActionParameters `json:"action,omitempty" tf:"action"`

	// +kubebuilder:validation:Optional
	ApplicationInsightsWebTestLocationAvailabilityCriteria []ApplicationInsightsWebTestLocationAvailabilityCriteriaParameters `json:"applicationInsightsWebTestLocationAvailabilityCriteria,omitempty" tf:"application_insights_web_test_location_availability_criteria"`

	// +kubebuilder:validation:Optional
	AutoMitigate *bool `json:"autoMitigate,omitempty" tf:"auto_mitigate"`

	// +kubebuilder:validation:Optional
	Criteria []MonitorMetricAlertCriteriaParameters `json:"criteria,omitempty" tf:"criteria"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description"`

	// +kubebuilder:validation:Optional
	DynamicCriteria []DynamicCriteriaParameters `json:"dynamicCriteria,omitempty" tf:"dynamic_criteria"`

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled"`

	// +kubebuilder:validation:Optional
	Frequency *string `json:"frequency,omitempty" tf:"frequency"`

	// +kubebuilder:validation:Required
	Name string `json:"name" tf:"name"`

	// +kubebuilder:validation:Required
	ResourceGroupName string `json:"resourceGroupName" tf:"resource_group_name"`

	// +kubebuilder:validation:Required
	Scopes []string `json:"scopes" tf:"scopes"`

	// +kubebuilder:validation:Optional
	Severity *int64 `json:"severity,omitempty" tf:"severity"`

	// +kubebuilder:validation:Optional
	Tags map[string]string `json:"tags,omitempty" tf:"tags"`

	// The location of the target pluginsdk. Required when using subscription, resource group scope or multiple scopes.
	// +kubebuilder:validation:Optional
	TargetResourceLocation *string `json:"targetResourceLocation,omitempty" tf:"target_resource_location"`

	// The resource type (e.g. Microsoft.Compute/virtualMachines) of the target pluginsdk. Required when using subscription, resource group scope or multiple scopes.
	// +kubebuilder:validation:Optional
	TargetResourceType *string `json:"targetResourceType,omitempty" tf:"target_resource_type"`

	// +kubebuilder:validation:Optional
	WindowSize *string `json:"windowSize,omitempty" tf:"window_size"`
}

// MonitorMetricAlertSpec defines the desired state of MonitorMetricAlert
type MonitorMetricAlertSpec struct {
	xpv1.ResourceSpec `json:",inline"`
	ForProvider       MonitorMetricAlertParameters `json:"forProvider"`
}

// MonitorMetricAlertStatus defines the observed state of MonitorMetricAlert.
type MonitorMetricAlertStatus struct {
	xpv1.ResourceStatus `json:",inline"`
	AtProvider          MonitorMetricAlertObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// MonitorMetricAlert is the Schema for the MonitorMetricAlerts API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,azure}
type MonitorMetricAlert struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              MonitorMetricAlertSpec   `json:"spec"`
	Status            MonitorMetricAlertStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// MonitorMetricAlertList contains a list of MonitorMetricAlerts
type MonitorMetricAlertList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []MonitorMetricAlert `json:"items"`
}

// Repository type metadata.
var (
	MonitorMetricAlertKind             = "MonitorMetricAlert"
	MonitorMetricAlertGroupKind        = schema.GroupKind{Group: Group, Kind: MonitorMetricAlertKind}.String()
	MonitorMetricAlertKindAPIVersion   = MonitorMetricAlertKind + "." + GroupVersion.String()
	MonitorMetricAlertGroupVersionKind = GroupVersion.WithKind(MonitorMetricAlertKind)
)

func init() {
	SchemeBuilder.Register(&MonitorMetricAlert{}, &MonitorMetricAlertList{})
}
