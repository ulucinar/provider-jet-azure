/*
Copyright 2020 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ApplicationPortsObservation struct {
}

type ApplicationPortsParameters struct {

	// +kubebuilder:validation:Required
	EndPort *int64 `json:"endPort" tf:"end_port,omitempty"`

	// +kubebuilder:validation:Required
	StartPort *int64 `json:"startPort" tf:"start_port,omitempty"`
}

type AzureActiveDirectoryObservation struct {
}

type AzureActiveDirectoryParameters struct {

	// +kubebuilder:validation:Required
	ClientApplicationID *string `json:"clientApplicationId" tf:"client_application_id,omitempty"`

	// +kubebuilder:validation:Required
	ClusterApplicationID *string `json:"clusterApplicationId" tf:"cluster_application_id,omitempty"`

	// +kubebuilder:validation:Required
	TenantID *string `json:"tenantId" tf:"tenant_id,omitempty"`
}

type CertificateCommonNamesObservation struct {
}

type CertificateCommonNamesParameters struct {

	// +kubebuilder:validation:Required
	CommonNames []CommonNamesParameters `json:"commonNames" tf:"common_names,omitempty"`

	// +kubebuilder:validation:Required
	X509StoreName *string `json:"x509StoreName" tf:"x509_store_name,omitempty"`
}

type CertificateObservation struct {
}

type CertificateParameters struct {

	// +kubebuilder:validation:Required
	Thumbprint *string `json:"thumbprint" tf:"thumbprint,omitempty"`

	// +kubebuilder:validation:Optional
	ThumbprintSecondary *string `json:"thumbprintSecondary,omitempty" tf:"thumbprint_secondary,omitempty"`

	// +kubebuilder:validation:Required
	X509StoreName *string `json:"x509StoreName" tf:"x509_store_name,omitempty"`
}

type ClientCertificateCommonNameObservation struct {
}

type ClientCertificateCommonNameParameters struct {

	// +kubebuilder:validation:Required
	CommonName *string `json:"commonName" tf:"common_name,omitempty"`

	// +kubebuilder:validation:Required
	IsAdmin *bool `json:"isAdmin" tf:"is_admin,omitempty"`

	// +kubebuilder:validation:Optional
	IssuerThumbprint *string `json:"issuerThumbprint,omitempty" tf:"issuer_thumbprint,omitempty"`
}

type ClientCertificateThumbprintObservation struct {
}

type ClientCertificateThumbprintParameters struct {

	// +kubebuilder:validation:Required
	IsAdmin *bool `json:"isAdmin" tf:"is_admin,omitempty"`

	// +kubebuilder:validation:Required
	Thumbprint *string `json:"thumbprint" tf:"thumbprint,omitempty"`
}

type ClusterObservation struct {
	ClusterEndpoint *string `json:"clusterEndpoint,omitempty" tf:"cluster_endpoint,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type ClusterParameters struct {

	// +kubebuilder:validation:Optional
	AddOnFeatures []*string `json:"addOnFeatures,omitempty" tf:"add_on_features,omitempty"`

	// +kubebuilder:validation:Optional
	AzureActiveDirectory []AzureActiveDirectoryParameters `json:"azureActiveDirectory,omitempty" tf:"azure_active_directory,omitempty"`

	// +kubebuilder:validation:Optional
	Certificate []CertificateParameters `json:"certificate,omitempty" tf:"certificate,omitempty"`

	// +kubebuilder:validation:Optional
	CertificateCommonNames []CertificateCommonNamesParameters `json:"certificateCommonNames,omitempty" tf:"certificate_common_names,omitempty"`

	// +kubebuilder:validation:Optional
	ClientCertificateCommonName []ClientCertificateCommonNameParameters `json:"clientCertificateCommonName,omitempty" tf:"client_certificate_common_name,omitempty"`

	// +kubebuilder:validation:Optional
	ClientCertificateThumbprint []ClientCertificateThumbprintParameters `json:"clientCertificateThumbprint,omitempty" tf:"client_certificate_thumbprint,omitempty"`

	// +kubebuilder:validation:Optional
	ClusterCodeVersion *string `json:"clusterCodeVersion,omitempty" tf:"cluster_code_version,omitempty"`

	// +kubebuilder:validation:Optional
	DiagnosticsConfig []DiagnosticsConfigParameters `json:"diagnosticsConfig,omitempty" tf:"diagnostics_config,omitempty"`

	// +kubebuilder:validation:Optional
	FabricSettings []FabricSettingsParameters `json:"fabricSettings,omitempty" tf:"fabric_settings,omitempty"`

	// +kubebuilder:validation:Required
	Location *string `json:"location" tf:"location,omitempty"`

	// +kubebuilder:validation:Required
	ManagementEndpoint *string `json:"managementEndpoint" tf:"management_endpoint,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	NodeType []NodeTypeParameters `json:"nodeType" tf:"node_type,omitempty"`

	// +kubebuilder:validation:Required
	ReliabilityLevel *string `json:"reliabilityLevel" tf:"reliability_level,omitempty"`

	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-jet-azure/apis/azure2/v1alpha2.ResourceGroup
	// +kubebuilder:validation:Optional
	ResourceGroupName *string `json:"resourceGroupName,omitempty" tf:"resource_group_name,omitempty"`

	// +kubebuilder:validation:Optional
	ResourceGroupNameRef *v1.Reference `json:"resourceGroupNameRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ResourceGroupNameSelector *v1.Selector `json:"resourceGroupNameSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ReverseProxyCertificate []ReverseProxyCertificateParameters `json:"reverseProxyCertificate,omitempty" tf:"reverse_proxy_certificate,omitempty"`

	// +kubebuilder:validation:Optional
	ReverseProxyCertificateCommonNames []ReverseProxyCertificateCommonNamesParameters `json:"reverseProxyCertificateCommonNames,omitempty" tf:"reverse_proxy_certificate_common_names,omitempty"`

	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// +kubebuilder:validation:Required
	UpgradeMode *string `json:"upgradeMode" tf:"upgrade_mode,omitempty"`

	// +kubebuilder:validation:Optional
	UpgradePolicy []UpgradePolicyParameters `json:"upgradePolicy,omitempty" tf:"upgrade_policy,omitempty"`

	// +kubebuilder:validation:Required
	VMImage *string `json:"vmImage" tf:"vm_image,omitempty"`
}

type CommonNamesObservation struct {
}

type CommonNamesParameters struct {

	// +kubebuilder:validation:Required
	CertificateCommonName *string `json:"certificateCommonName" tf:"certificate_common_name,omitempty"`

	// +kubebuilder:validation:Optional
	CertificateIssuerThumbprint *string `json:"certificateIssuerThumbprint,omitempty" tf:"certificate_issuer_thumbprint,omitempty"`
}

type DeltaHealthPolicyObservation struct {
}

type DeltaHealthPolicyParameters struct {

	// +kubebuilder:validation:Optional
	MaxDeltaUnhealthyApplicationsPercent *int64 `json:"maxDeltaUnhealthyApplicationsPercent,omitempty" tf:"max_delta_unhealthy_applications_percent,omitempty"`

	// +kubebuilder:validation:Optional
	MaxDeltaUnhealthyNodesPercent *int64 `json:"maxDeltaUnhealthyNodesPercent,omitempty" tf:"max_delta_unhealthy_nodes_percent,omitempty"`

	// +kubebuilder:validation:Optional
	MaxUpgradeDomainDeltaUnhealthyNodesPercent *int64 `json:"maxUpgradeDomainDeltaUnhealthyNodesPercent,omitempty" tf:"max_upgrade_domain_delta_unhealthy_nodes_percent,omitempty"`
}

type DiagnosticsConfigObservation struct {
}

type DiagnosticsConfigParameters struct {

	// +kubebuilder:validation:Required
	BlobEndpoint *string `json:"blobEndpoint" tf:"blob_endpoint,omitempty"`

	// +kubebuilder:validation:Required
	ProtectedAccountKeyName *string `json:"protectedAccountKeyName" tf:"protected_account_key_name,omitempty"`

	// +kubebuilder:validation:Required
	QueueEndpoint *string `json:"queueEndpoint" tf:"queue_endpoint,omitempty"`

	// +kubebuilder:validation:Required
	StorageAccountName *string `json:"storageAccountName" tf:"storage_account_name,omitempty"`

	// +kubebuilder:validation:Required
	TableEndpoint *string `json:"tableEndpoint" tf:"table_endpoint,omitempty"`
}

type EphemeralPortsObservation struct {
}

type EphemeralPortsParameters struct {

	// +kubebuilder:validation:Required
	EndPort *int64 `json:"endPort" tf:"end_port,omitempty"`

	// +kubebuilder:validation:Required
	StartPort *int64 `json:"startPort" tf:"start_port,omitempty"`
}

type FabricSettingsObservation struct {
}

type FabricSettingsParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Parameters map[string]*string `json:"parameters,omitempty" tf:"parameters,omitempty"`
}

type HealthPolicyObservation struct {
}

type HealthPolicyParameters struct {

	// +kubebuilder:validation:Optional
	MaxUnhealthyApplicationsPercent *int64 `json:"maxUnhealthyApplicationsPercent,omitempty" tf:"max_unhealthy_applications_percent,omitempty"`

	// +kubebuilder:validation:Optional
	MaxUnhealthyNodesPercent *int64 `json:"maxUnhealthyNodesPercent,omitempty" tf:"max_unhealthy_nodes_percent,omitempty"`
}

type NodeTypeObservation struct {
}

type NodeTypeParameters struct {

	// +kubebuilder:validation:Optional
	ApplicationPorts []ApplicationPortsParameters `json:"applicationPorts,omitempty" tf:"application_ports,omitempty"`

	// +kubebuilder:validation:Optional
	Capacities map[string]*string `json:"capacities,omitempty" tf:"capacities,omitempty"`

	// +kubebuilder:validation:Required
	ClientEndpointPort *int64 `json:"clientEndpointPort" tf:"client_endpoint_port,omitempty"`

	// +kubebuilder:validation:Optional
	DurabilityLevel *string `json:"durabilityLevel,omitempty" tf:"durability_level,omitempty"`

	// +kubebuilder:validation:Optional
	EphemeralPorts []EphemeralPortsParameters `json:"ephemeralPorts,omitempty" tf:"ephemeral_ports,omitempty"`

	// +kubebuilder:validation:Required
	HTTPEndpointPort *int64 `json:"httpEndpointPort" tf:"http_endpoint_port,omitempty"`

	// +kubebuilder:validation:Required
	InstanceCount *int64 `json:"instanceCount" tf:"instance_count,omitempty"`

	// +kubebuilder:validation:Required
	IsPrimary *bool `json:"isPrimary" tf:"is_primary,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	PlacementProperties map[string]*string `json:"placementProperties,omitempty" tf:"placement_properties,omitempty"`

	// +kubebuilder:validation:Optional
	ReverseProxyEndpointPort *int64 `json:"reverseProxyEndpointPort,omitempty" tf:"reverse_proxy_endpoint_port,omitempty"`
}

type ReverseProxyCertificateCommonNamesCommonNamesObservation struct {
}

type ReverseProxyCertificateCommonNamesCommonNamesParameters struct {

	// +kubebuilder:validation:Required
	CertificateCommonName *string `json:"certificateCommonName" tf:"certificate_common_name,omitempty"`

	// +kubebuilder:validation:Optional
	CertificateIssuerThumbprint *string `json:"certificateIssuerThumbprint,omitempty" tf:"certificate_issuer_thumbprint,omitempty"`
}

type ReverseProxyCertificateCommonNamesObservation struct {
}

type ReverseProxyCertificateCommonNamesParameters struct {

	// +kubebuilder:validation:Required
	CommonNames []ReverseProxyCertificateCommonNamesCommonNamesParameters `json:"commonNames" tf:"common_names,omitempty"`

	// +kubebuilder:validation:Required
	X509StoreName *string `json:"x509StoreName" tf:"x509_store_name,omitempty"`
}

type ReverseProxyCertificateObservation struct {
}

type ReverseProxyCertificateParameters struct {

	// +kubebuilder:validation:Required
	Thumbprint *string `json:"thumbprint" tf:"thumbprint,omitempty"`

	// +kubebuilder:validation:Optional
	ThumbprintSecondary *string `json:"thumbprintSecondary,omitempty" tf:"thumbprint_secondary,omitempty"`

	// +kubebuilder:validation:Required
	X509StoreName *string `json:"x509StoreName" tf:"x509_store_name,omitempty"`
}

type UpgradePolicyObservation struct {
}

type UpgradePolicyParameters struct {

	// +kubebuilder:validation:Optional
	DeltaHealthPolicy []DeltaHealthPolicyParameters `json:"deltaHealthPolicy,omitempty" tf:"delta_health_policy,omitempty"`

	// +kubebuilder:validation:Optional
	ForceRestartEnabled *bool `json:"forceRestartEnabled,omitempty" tf:"force_restart_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	HealthCheckRetryTimeout *string `json:"healthCheckRetryTimeout,omitempty" tf:"health_check_retry_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	HealthCheckStableDuration *string `json:"healthCheckStableDuration,omitempty" tf:"health_check_stable_duration,omitempty"`

	// +kubebuilder:validation:Optional
	HealthCheckWaitDuration *string `json:"healthCheckWaitDuration,omitempty" tf:"health_check_wait_duration,omitempty"`

	// +kubebuilder:validation:Optional
	HealthPolicy []HealthPolicyParameters `json:"healthPolicy,omitempty" tf:"health_policy,omitempty"`

	// +kubebuilder:validation:Optional
	UpgradeDomainTimeout *string `json:"upgradeDomainTimeout,omitempty" tf:"upgrade_domain_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	UpgradeReplicaSetCheckTimeout *string `json:"upgradeReplicaSetCheckTimeout,omitempty" tf:"upgrade_replica_set_check_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	UpgradeTimeout *string `json:"upgradeTimeout,omitempty" tf:"upgrade_timeout,omitempty"`
}

// ClusterSpec defines the desired state of Cluster
type ClusterSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ClusterParameters `json:"forProvider"`
}

// ClusterStatus defines the observed state of Cluster.
type ClusterStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ClusterObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Cluster is the Schema for the Clusters API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,azurejet}
type Cluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ClusterSpec   `json:"spec"`
	Status            ClusterStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ClusterList contains a list of Clusters
type ClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Cluster `json:"items"`
}

// Repository type metadata.
var (
	Cluster_Kind             = "Cluster"
	Cluster_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Cluster_Kind}.String()
	Cluster_KindAPIVersion   = Cluster_Kind + "." + CRDGroupVersion.String()
	Cluster_GroupVersionKind = CRDGroupVersion.WithKind(Cluster_Kind)
)

func init() {
	SchemeBuilder.Register(&Cluster{}, &ClusterList{})
}
