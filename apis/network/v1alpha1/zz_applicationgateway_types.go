/*
Copyright 2020 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ApplicationGatewayObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type ApplicationGatewayParameters struct {

	// +kubebuilder:validation:Optional
	AuthenticationCertificate []AuthenticationCertificateParameters `json:"authenticationCertificate,omitempty" tf:"authentication_certificate,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleConfiguration []AutoscaleConfigurationParameters `json:"autoscaleConfiguration,omitempty" tf:"autoscale_configuration,omitempty"`

	// +kubebuilder:validation:Required
	BackendAddressPool []BackendAddressPoolParameters `json:"backendAddressPool" tf:"backend_address_pool,omitempty"`

	// +kubebuilder:validation:Required
	BackendHTTPSettings []BackendHTTPSettingsParameters `json:"backendHttpSettings" tf:"backend_http_settings,omitempty"`

	// +kubebuilder:validation:Optional
	CustomErrorConfiguration []CustomErrorConfigurationParameters `json:"customErrorConfiguration,omitempty" tf:"custom_error_configuration,omitempty"`

	// +kubebuilder:validation:Optional
	EnableHttp2 *bool `json:"enableHttp2,omitempty" tf:"enable_http2,omitempty"`

	// +kubebuilder:validation:Optional
	FirewallPolicyID *string `json:"firewallPolicyId,omitempty" tf:"firewall_policy_id,omitempty"`

	// +kubebuilder:validation:Required
	FrontendIPConfiguration []FrontendIPConfigurationParameters `json:"frontendIpConfiguration" tf:"frontend_ip_configuration,omitempty"`

	// +kubebuilder:validation:Required
	FrontendPort []FrontendPortParameters `json:"frontendPort" tf:"frontend_port,omitempty"`

	// +kubebuilder:validation:Required
	GatewayIPConfiguration []GatewayIPConfigurationParameters `json:"gatewayIpConfiguration" tf:"gateway_ip_configuration,omitempty"`

	// +kubebuilder:validation:Required
	HTTPListener []HTTPListenerParameters `json:"httpListener" tf:"http_listener,omitempty"`

	// +kubebuilder:validation:Optional
	Identity []IdentityParameters `json:"identity,omitempty" tf:"identity,omitempty"`

	// +kubebuilder:validation:Required
	Location *string `json:"location" tf:"location,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Probe []ProbeParameters `json:"probe,omitempty" tf:"probe,omitempty"`

	// +kubebuilder:validation:Optional
	RedirectConfiguration []RedirectConfigurationParameters `json:"redirectConfiguration,omitempty" tf:"redirect_configuration,omitempty"`

	// +kubebuilder:validation:Required
	RequestRoutingRule []RequestRoutingRuleParameters `json:"requestRoutingRule" tf:"request_routing_rule,omitempty"`

	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-jet-azure/apis/azure2/v1alpha2.ResourceGroup
	// +kubebuilder:validation:Optional
	ResourceGroupName *string `json:"resourceGroupName,omitempty" tf:"resource_group_name,omitempty"`

	// +kubebuilder:validation:Optional
	ResourceGroupNameRef *v1.Reference `json:"resourceGroupNameRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ResourceGroupNameSelector *v1.Selector `json:"resourceGroupNameSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	RewriteRuleSet []RewriteRuleSetParameters `json:"rewriteRuleSet,omitempty" tf:"rewrite_rule_set,omitempty"`

	// +kubebuilder:validation:Optional
	SSLCertificate []SSLCertificateParameters `json:"sslCertificate,omitempty" tf:"ssl_certificate,omitempty"`

	// +kubebuilder:validation:Optional
	SSLPolicy []SSLPolicyParameters `json:"sslPolicy,omitempty" tf:"ssl_policy,omitempty"`

	// +kubebuilder:validation:Optional
	SSLProfile []SSLProfileParameters `json:"sslProfile,omitempty" tf:"ssl_profile,omitempty"`

	// +kubebuilder:validation:Required
	Sku []SkuParameters `json:"sku" tf:"sku,omitempty"`

	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// +kubebuilder:validation:Optional
	TrustedClientCertificate []TrustedClientCertificateParameters `json:"trustedClientCertificate,omitempty" tf:"trusted_client_certificate,omitempty"`

	// +kubebuilder:validation:Optional
	TrustedRootCertificate []TrustedRootCertificateParameters `json:"trustedRootCertificate,omitempty" tf:"trusted_root_certificate,omitempty"`

	// +kubebuilder:validation:Optional
	URLPathMap []URLPathMapParameters `json:"urlPathMap,omitempty" tf:"url_path_map,omitempty"`

	// +kubebuilder:validation:Optional
	WafConfiguration []WafConfigurationParameters `json:"wafConfiguration,omitempty" tf:"waf_configuration,omitempty"`

	// +kubebuilder:validation:Optional
	Zones []*string `json:"zones,omitempty" tf:"zones,omitempty"`
}

type AuthenticationCertificateObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type AuthenticationCertificateParameters struct {

	// +kubebuilder:validation:Required
	DataSecretRef v1.SecretKeySelector `json:"dataSecretRef" tf:"-"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`
}

type AutoscaleConfigurationObservation struct {
}

type AutoscaleConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	MaxCapacity *int64 `json:"maxCapacity,omitempty" tf:"max_capacity,omitempty"`

	// +kubebuilder:validation:Required
	MinCapacity *int64 `json:"minCapacity" tf:"min_capacity,omitempty"`
}

type BackendAddressPoolObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type BackendAddressPoolParameters struct {

	// +kubebuilder:validation:Optional
	Fqdns []*string `json:"fqdns,omitempty" tf:"fqdns,omitempty"`

	// +kubebuilder:validation:Optional
	IPAddresses []*string `json:"ipAddresses,omitempty" tf:"ip_addresses,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`
}

type BackendHTTPSettingsAuthenticationCertificateObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type BackendHTTPSettingsAuthenticationCertificateParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`
}

type BackendHTTPSettingsObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	ProbeID *string `json:"probeId,omitempty" tf:"probe_id,omitempty"`
}

type BackendHTTPSettingsParameters struct {

	// +kubebuilder:validation:Optional
	AffinityCookieName *string `json:"affinityCookieName,omitempty" tf:"affinity_cookie_name,omitempty"`

	// +kubebuilder:validation:Optional
	AuthenticationCertificate []BackendHTTPSettingsAuthenticationCertificateParameters `json:"authenticationCertificate,omitempty" tf:"authentication_certificate,omitempty"`

	// +kubebuilder:validation:Optional
	ConnectionDraining []ConnectionDrainingParameters `json:"connectionDraining,omitempty" tf:"connection_draining,omitempty"`

	// +kubebuilder:validation:Required
	CookieBasedAffinity *string `json:"cookieBasedAffinity" tf:"cookie_based_affinity,omitempty"`

	// +kubebuilder:validation:Optional
	HostName *string `json:"hostName,omitempty" tf:"host_name,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// +kubebuilder:validation:Optional
	PickHostNameFromBackendAddress *bool `json:"pickHostNameFromBackendAddress,omitempty" tf:"pick_host_name_from_backend_address,omitempty"`

	// +kubebuilder:validation:Required
	Port *int64 `json:"port" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	ProbeName *string `json:"probeName,omitempty" tf:"probe_name,omitempty"`

	// +kubebuilder:validation:Required
	Protocol *string `json:"protocol" tf:"protocol,omitempty"`

	// +kubebuilder:validation:Optional
	RequestTimeout *int64 `json:"requestTimeout,omitempty" tf:"request_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	TrustedRootCertificateNames []*string `json:"trustedRootCertificateNames,omitempty" tf:"trusted_root_certificate_names,omitempty"`
}

type ConditionObservation struct {
}

type ConditionParameters struct {

	// +kubebuilder:validation:Optional
	IgnoreCase *bool `json:"ignoreCase,omitempty" tf:"ignore_case,omitempty"`

	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// +kubebuilder:validation:Required
	Pattern *string `json:"pattern" tf:"pattern,omitempty"`

	// +kubebuilder:validation:Required
	Variable *string `json:"variable" tf:"variable,omitempty"`
}

type ConnectionDrainingObservation struct {
}

type ConnectionDrainingParameters struct {

	// +kubebuilder:validation:Required
	DrainTimeoutSec *int64 `json:"drainTimeoutSec" tf:"drain_timeout_sec,omitempty"`

	// +kubebuilder:validation:Required
	Enabled *bool `json:"enabled" tf:"enabled,omitempty"`
}

type CustomErrorConfigurationObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type CustomErrorConfigurationParameters struct {

	// +kubebuilder:validation:Required
	CustomErrorPageURL *string `json:"customErrorPageUrl" tf:"custom_error_page_url,omitempty"`

	// +kubebuilder:validation:Required
	StatusCode *string `json:"statusCode" tf:"status_code,omitempty"`
}

type DisabledRuleGroupObservation struct {
}

type DisabledRuleGroupParameters struct {

	// +kubebuilder:validation:Required
	RuleGroupName *string `json:"ruleGroupName" tf:"rule_group_name,omitempty"`

	// +kubebuilder:validation:Optional
	Rules []*int64 `json:"rules,omitempty" tf:"rules,omitempty"`
}

type ExclusionObservation struct {
}

type ExclusionParameters struct {

	// +kubebuilder:validation:Required
	MatchVariable *string `json:"matchVariable" tf:"match_variable,omitempty"`

	// +kubebuilder:validation:Optional
	Selector *string `json:"selector,omitempty" tf:"selector,omitempty"`

	// +kubebuilder:validation:Optional
	SelectorMatchOperator *string `json:"selectorMatchOperator,omitempty" tf:"selector_match_operator,omitempty"`
}

type FrontendIPConfigurationObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type FrontendIPConfigurationParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	PrivateIPAddress *string `json:"privateIpAddress,omitempty" tf:"private_ip_address,omitempty"`

	// +kubebuilder:validation:Optional
	PrivateIPAddressAllocation *string `json:"privateIpAddressAllocation,omitempty" tf:"private_ip_address_allocation,omitempty"`

	// +kubebuilder:validation:Optional
	PublicIPAddressID *string `json:"publicIpAddressId,omitempty" tf:"public_ip_address_id,omitempty"`

	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-jet-azure/apis/network/v1alpha2.Subnet
	// +crossplane:generate:reference:extractor=github.com/crossplane-contrib/provider-jet-azure/apis/rconfig.ExtractResourceID()
	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetIDRef *v1.Reference `json:"subnetIdRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	SubnetIDSelector *v1.Selector `json:"subnetIdSelector,omitempty" tf:"-"`
}

type FrontendPortObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type FrontendPortParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Port *int64 `json:"port" tf:"port,omitempty"`
}

type GatewayIPConfigurationObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type GatewayIPConfigurationParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-jet-azure/apis/network/v1alpha2.Subnet
	// +crossplane:generate:reference:extractor=github.com/crossplane-contrib/provider-jet-azure/apis/rconfig.ExtractResourceID()
	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetIDRef *v1.Reference `json:"subnetIdRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	SubnetIDSelector *v1.Selector `json:"subnetIdSelector,omitempty" tf:"-"`
}

type HTTPListenerCustomErrorConfigurationObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type HTTPListenerCustomErrorConfigurationParameters struct {

	// +kubebuilder:validation:Required
	CustomErrorPageURL *string `json:"customErrorPageUrl" tf:"custom_error_page_url,omitempty"`

	// +kubebuilder:validation:Required
	StatusCode *string `json:"statusCode" tf:"status_code,omitempty"`
}

type HTTPListenerObservation struct {
	FrontendIPConfigurationID *string `json:"frontendIpConfigurationId,omitempty" tf:"frontend_ip_configuration_id,omitempty"`

	FrontendPortID *string `json:"frontendPortId,omitempty" tf:"frontend_port_id,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	SSLCertificateID *string `json:"sslCertificateId,omitempty" tf:"ssl_certificate_id,omitempty"`

	SSLProfileID *string `json:"sslProfileId,omitempty" tf:"ssl_profile_id,omitempty"`
}

type HTTPListenerParameters struct {

	// +kubebuilder:validation:Optional
	CustomErrorConfiguration []HTTPListenerCustomErrorConfigurationParameters `json:"customErrorConfiguration,omitempty" tf:"custom_error_configuration,omitempty"`

	// +kubebuilder:validation:Optional
	FirewallPolicyID *string `json:"firewallPolicyId,omitempty" tf:"firewall_policy_id,omitempty"`

	// +kubebuilder:validation:Required
	FrontendIPConfigurationName *string `json:"frontendIpConfigurationName" tf:"frontend_ip_configuration_name,omitempty"`

	// +kubebuilder:validation:Required
	FrontendPortName *string `json:"frontendPortName" tf:"frontend_port_name,omitempty"`

	// +kubebuilder:validation:Optional
	HostName *string `json:"hostName,omitempty" tf:"host_name,omitempty"`

	// +kubebuilder:validation:Optional
	HostNames []*string `json:"hostNames,omitempty" tf:"host_names,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Protocol *string `json:"protocol" tf:"protocol,omitempty"`

	// +kubebuilder:validation:Optional
	RequireSni *bool `json:"requireSni,omitempty" tf:"require_sni,omitempty"`

	// +kubebuilder:validation:Optional
	SSLCertificateName *string `json:"sslCertificateName,omitempty" tf:"ssl_certificate_name,omitempty"`

	// +kubebuilder:validation:Optional
	SSLProfileName *string `json:"sslProfileName,omitempty" tf:"ssl_profile_name,omitempty"`
}

type IdentityObservation struct {
}

type IdentityParameters struct {

	// +kubebuilder:validation:Required
	IdentityIds []*string `json:"identityIds" tf:"identity_ids,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type MatchObservation struct {
}

type MatchParameters struct {

	// +kubebuilder:validation:Optional
	Body *string `json:"body,omitempty" tf:"body,omitempty"`

	// +kubebuilder:validation:Optional
	StatusCode []*string `json:"statusCode,omitempty" tf:"status_code,omitempty"`
}

type PathRuleObservation struct {
	BackendAddressPoolID *string `json:"backendAddressPoolId,omitempty" tf:"backend_address_pool_id,omitempty"`

	BackendHTTPSettingsID *string `json:"backendHttpSettingsId,omitempty" tf:"backend_http_settings_id,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	RedirectConfigurationID *string `json:"redirectConfigurationId,omitempty" tf:"redirect_configuration_id,omitempty"`

	RewriteRuleSetID *string `json:"rewriteRuleSetId,omitempty" tf:"rewrite_rule_set_id,omitempty"`
}

type PathRuleParameters struct {

	// +kubebuilder:validation:Optional
	BackendAddressPoolName *string `json:"backendAddressPoolName,omitempty" tf:"backend_address_pool_name,omitempty"`

	// +kubebuilder:validation:Optional
	BackendHTTPSettingsName *string `json:"backendHttpSettingsName,omitempty" tf:"backend_http_settings_name,omitempty"`

	// +kubebuilder:validation:Optional
	FirewallPolicyID *string `json:"firewallPolicyId,omitempty" tf:"firewall_policy_id,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Paths []*string `json:"paths" tf:"paths,omitempty"`

	// +kubebuilder:validation:Optional
	RedirectConfigurationName *string `json:"redirectConfigurationName,omitempty" tf:"redirect_configuration_name,omitempty"`

	// +kubebuilder:validation:Optional
	RewriteRuleSetName *string `json:"rewriteRuleSetName,omitempty" tf:"rewrite_rule_set_name,omitempty"`
}

type ProbeObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type ProbeParameters struct {

	// +kubebuilder:validation:Optional
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// +kubebuilder:validation:Required
	Interval *int64 `json:"interval" tf:"interval,omitempty"`

	// +kubebuilder:validation:Optional
	Match []MatchParameters `json:"match,omitempty" tf:"match,omitempty"`

	// +kubebuilder:validation:Optional
	MinimumServers *int64 `json:"minimumServers,omitempty" tf:"minimum_servers,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Path *string `json:"path" tf:"path,omitempty"`

	// +kubebuilder:validation:Optional
	PickHostNameFromBackendHTTPSettings *bool `json:"pickHostNameFromBackendHttpSettings,omitempty" tf:"pick_host_name_from_backend_http_settings,omitempty"`

	// +kubebuilder:validation:Optional
	Port *int64 `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Required
	Protocol *string `json:"protocol" tf:"protocol,omitempty"`

	// +kubebuilder:validation:Required
	Timeout *int64 `json:"timeout" tf:"timeout,omitempty"`

	// +kubebuilder:validation:Required
	UnhealthyThreshold *int64 `json:"unhealthyThreshold" tf:"unhealthy_threshold,omitempty"`
}

type RedirectConfigurationObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	TargetListenerID *string `json:"targetListenerId,omitempty" tf:"target_listener_id,omitempty"`
}

type RedirectConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	IncludePath *bool `json:"includePath,omitempty" tf:"include_path,omitempty"`

	// +kubebuilder:validation:Optional
	IncludeQueryString *bool `json:"includeQueryString,omitempty" tf:"include_query_string,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	RedirectType *string `json:"redirectType" tf:"redirect_type,omitempty"`

	// +kubebuilder:validation:Optional
	TargetListenerName *string `json:"targetListenerName,omitempty" tf:"target_listener_name,omitempty"`

	// +kubebuilder:validation:Optional
	TargetURL *string `json:"targetUrl,omitempty" tf:"target_url,omitempty"`
}

type RequestHeaderConfigurationObservation struct {
}

type RequestHeaderConfigurationParameters struct {

	// +kubebuilder:validation:Required
	HeaderName *string `json:"headerName" tf:"header_name,omitempty"`

	// +kubebuilder:validation:Required
	HeaderValue *string `json:"headerValue" tf:"header_value,omitempty"`
}

type RequestRoutingRuleObservation struct {
	BackendAddressPoolID *string `json:"backendAddressPoolId,omitempty" tf:"backend_address_pool_id,omitempty"`

	BackendHTTPSettingsID *string `json:"backendHttpSettingsId,omitempty" tf:"backend_http_settings_id,omitempty"`

	HTTPListenerID *string `json:"httpListenerId,omitempty" tf:"http_listener_id,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	RedirectConfigurationID *string `json:"redirectConfigurationId,omitempty" tf:"redirect_configuration_id,omitempty"`

	RewriteRuleSetID *string `json:"rewriteRuleSetId,omitempty" tf:"rewrite_rule_set_id,omitempty"`

	URLPathMapID *string `json:"urlPathMapId,omitempty" tf:"url_path_map_id,omitempty"`
}

type RequestRoutingRuleParameters struct {

	// +kubebuilder:validation:Optional
	BackendAddressPoolName *string `json:"backendAddressPoolName,omitempty" tf:"backend_address_pool_name,omitempty"`

	// +kubebuilder:validation:Optional
	BackendHTTPSettingsName *string `json:"backendHttpSettingsName,omitempty" tf:"backend_http_settings_name,omitempty"`

	// +kubebuilder:validation:Required
	HTTPListenerName *string `json:"httpListenerName" tf:"http_listener_name,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	RedirectConfigurationName *string `json:"redirectConfigurationName,omitempty" tf:"redirect_configuration_name,omitempty"`

	// +kubebuilder:validation:Optional
	RewriteRuleSetName *string `json:"rewriteRuleSetName,omitempty" tf:"rewrite_rule_set_name,omitempty"`

	// +kubebuilder:validation:Required
	RuleType *string `json:"ruleType" tf:"rule_type,omitempty"`

	// +kubebuilder:validation:Optional
	URLPathMapName *string `json:"urlPathMapName,omitempty" tf:"url_path_map_name,omitempty"`
}

type ResponseHeaderConfigurationObservation struct {
}

type ResponseHeaderConfigurationParameters struct {

	// +kubebuilder:validation:Required
	HeaderName *string `json:"headerName" tf:"header_name,omitempty"`

	// +kubebuilder:validation:Required
	HeaderValue *string `json:"headerValue" tf:"header_value,omitempty"`
}

type RewriteRuleObservation struct {
}

type RewriteRuleParameters struct {

	// +kubebuilder:validation:Optional
	Condition []ConditionParameters `json:"condition,omitempty" tf:"condition,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	RequestHeaderConfiguration []RequestHeaderConfigurationParameters `json:"requestHeaderConfiguration,omitempty" tf:"request_header_configuration,omitempty"`

	// +kubebuilder:validation:Optional
	ResponseHeaderConfiguration []ResponseHeaderConfigurationParameters `json:"responseHeaderConfiguration,omitempty" tf:"response_header_configuration,omitempty"`

	// +kubebuilder:validation:Required
	RuleSequence *int64 `json:"ruleSequence" tf:"rule_sequence,omitempty"`

	// +kubebuilder:validation:Optional
	URL []URLParameters `json:"url,omitempty" tf:"url,omitempty"`
}

type RewriteRuleSetObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type RewriteRuleSetParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	RewriteRule []RewriteRuleParameters `json:"rewriteRule,omitempty" tf:"rewrite_rule,omitempty"`
}

type SSLCertificateObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	PublicCertData *string `json:"publicCertData,omitempty" tf:"public_cert_data,omitempty"`
}

type SSLCertificateParameters struct {

	// +kubebuilder:validation:Optional
	DataSecretRef *v1.SecretKeySelector `json:"dataSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	KeyVaultSecretID *string `json:"keyVaultSecretId,omitempty" tf:"key_vault_secret_id,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	PasswordSecretRef *v1.SecretKeySelector `json:"passwordSecretRef,omitempty" tf:"-"`
}

type SSLPolicyObservation struct {
}

type SSLPolicyParameters struct {

	// +kubebuilder:validation:Optional
	CipherSuites []*string `json:"cipherSuites,omitempty" tf:"cipher_suites,omitempty"`

	// +kubebuilder:validation:Optional
	DisabledProtocols []*string `json:"disabledProtocols,omitempty" tf:"disabled_protocols,omitempty"`

	// +kubebuilder:validation:Optional
	MinProtocolVersion *string `json:"minProtocolVersion,omitempty" tf:"min_protocol_version,omitempty"`

	// +kubebuilder:validation:Optional
	PolicyName *string `json:"policyName,omitempty" tf:"policy_name,omitempty"`

	// +kubebuilder:validation:Optional
	PolicyType *string `json:"policyType,omitempty" tf:"policy_type,omitempty"`
}

type SSLProfileObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type SSLProfileParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	SSLPolicy []SSLProfileSSLPolicyParameters `json:"sslPolicy,omitempty" tf:"ssl_policy,omitempty"`

	// +kubebuilder:validation:Optional
	TrustedClientCertificateNames []*string `json:"trustedClientCertificateNames,omitempty" tf:"trusted_client_certificate_names,omitempty"`

	// +kubebuilder:validation:Optional
	VerifyClientCertIssuerDn *bool `json:"verifyClientCertIssuerDn,omitempty" tf:"verify_client_cert_issuer_dn,omitempty"`
}

type SSLProfileSSLPolicyObservation struct {
}

type SSLProfileSSLPolicyParameters struct {

	// +kubebuilder:validation:Optional
	CipherSuites []*string `json:"cipherSuites,omitempty" tf:"cipher_suites,omitempty"`

	// +kubebuilder:validation:Optional
	DisabledProtocols []*string `json:"disabledProtocols,omitempty" tf:"disabled_protocols,omitempty"`

	// +kubebuilder:validation:Optional
	MinProtocolVersion *string `json:"minProtocolVersion,omitempty" tf:"min_protocol_version,omitempty"`

	// +kubebuilder:validation:Optional
	PolicyName *string `json:"policyName,omitempty" tf:"policy_name,omitempty"`

	// +kubebuilder:validation:Optional
	PolicyType *string `json:"policyType,omitempty" tf:"policy_type,omitempty"`
}

type SkuObservation struct {
}

type SkuParameters struct {

	// +kubebuilder:validation:Optional
	Capacity *int64 `json:"capacity,omitempty" tf:"capacity,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Tier *string `json:"tier" tf:"tier,omitempty"`
}

type TrustedClientCertificateObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type TrustedClientCertificateParameters struct {

	// +kubebuilder:validation:Required
	DataSecretRef v1.SecretKeySelector `json:"dataSecretRef" tf:"-"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`
}

type TrustedRootCertificateObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type TrustedRootCertificateParameters struct {

	// +kubebuilder:validation:Required
	DataSecretRef v1.SecretKeySelector `json:"dataSecretRef" tf:"-"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`
}

type URLObservation struct {
}

type URLParameters struct {

	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// +kubebuilder:validation:Optional
	QueryString *string `json:"queryString,omitempty" tf:"query_string,omitempty"`

	// +kubebuilder:validation:Optional
	Reroute *bool `json:"reroute,omitempty" tf:"reroute,omitempty"`
}

type URLPathMapObservation struct {
	DefaultBackendAddressPoolID *string `json:"defaultBackendAddressPoolId,omitempty" tf:"default_backend_address_pool_id,omitempty"`

	DefaultBackendHTTPSettingsID *string `json:"defaultBackendHttpSettingsId,omitempty" tf:"default_backend_http_settings_id,omitempty"`

	DefaultRedirectConfigurationID *string `json:"defaultRedirectConfigurationId,omitempty" tf:"default_redirect_configuration_id,omitempty"`

	DefaultRewriteRuleSetID *string `json:"defaultRewriteRuleSetId,omitempty" tf:"default_rewrite_rule_set_id,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type URLPathMapParameters struct {

	// +kubebuilder:validation:Optional
	DefaultBackendAddressPoolName *string `json:"defaultBackendAddressPoolName,omitempty" tf:"default_backend_address_pool_name,omitempty"`

	// +kubebuilder:validation:Optional
	DefaultBackendHTTPSettingsName *string `json:"defaultBackendHttpSettingsName,omitempty" tf:"default_backend_http_settings_name,omitempty"`

	// +kubebuilder:validation:Optional
	DefaultRedirectConfigurationName *string `json:"defaultRedirectConfigurationName,omitempty" tf:"default_redirect_configuration_name,omitempty"`

	// +kubebuilder:validation:Optional
	DefaultRewriteRuleSetName *string `json:"defaultRewriteRuleSetName,omitempty" tf:"default_rewrite_rule_set_name,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	PathRule []PathRuleParameters `json:"pathRule" tf:"path_rule,omitempty"`
}

type WafConfigurationObservation struct {
}

type WafConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	DisabledRuleGroup []DisabledRuleGroupParameters `json:"disabledRuleGroup,omitempty" tf:"disabled_rule_group,omitempty"`

	// +kubebuilder:validation:Required
	Enabled *bool `json:"enabled" tf:"enabled,omitempty"`

	// +kubebuilder:validation:Optional
	Exclusion []ExclusionParameters `json:"exclusion,omitempty" tf:"exclusion,omitempty"`

	// +kubebuilder:validation:Optional
	FileUploadLimitMb *int64 `json:"fileUploadLimitMb,omitempty" tf:"file_upload_limit_mb,omitempty"`

	// +kubebuilder:validation:Required
	FirewallMode *string `json:"firewallMode" tf:"firewall_mode,omitempty"`

	// +kubebuilder:validation:Optional
	MaxRequestBodySizeKb *int64 `json:"maxRequestBodySizeKb,omitempty" tf:"max_request_body_size_kb,omitempty"`

	// +kubebuilder:validation:Optional
	RequestBodyCheck *bool `json:"requestBodyCheck,omitempty" tf:"request_body_check,omitempty"`

	// +kubebuilder:validation:Optional
	RuleSetType *string `json:"ruleSetType,omitempty" tf:"rule_set_type,omitempty"`

	// +kubebuilder:validation:Required
	RuleSetVersion *string `json:"ruleSetVersion" tf:"rule_set_version,omitempty"`
}

// ApplicationGatewaySpec defines the desired state of ApplicationGateway
type ApplicationGatewaySpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ApplicationGatewayParameters `json:"forProvider"`
}

// ApplicationGatewayStatus defines the observed state of ApplicationGateway.
type ApplicationGatewayStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ApplicationGatewayObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// ApplicationGateway is the Schema for the ApplicationGateways API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,azurejet}
type ApplicationGateway struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ApplicationGatewaySpec   `json:"spec"`
	Status            ApplicationGatewayStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ApplicationGatewayList contains a list of ApplicationGateways
type ApplicationGatewayList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ApplicationGateway `json:"items"`
}

// Repository type metadata.
var (
	ApplicationGateway_Kind             = "ApplicationGateway"
	ApplicationGateway_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: ApplicationGateway_Kind}.String()
	ApplicationGateway_KindAPIVersion   = ApplicationGateway_Kind + "." + CRDGroupVersion.String()
	ApplicationGateway_GroupVersionKind = CRDGroupVersion.WithKind(ApplicationGateway_Kind)
)

func init() {
	SchemeBuilder.Register(&ApplicationGateway{}, &ApplicationGatewayList{})
}
