/*
Copyright 2020 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AzureActiveDirectoryAuthenticationObservation struct {
}

type AzureActiveDirectoryAuthenticationParameters struct {

	// +kubebuilder:validation:Required
	Audience *string `json:"audience" tf:"audience,omitempty"`

	// +kubebuilder:validation:Required
	Issuer *string `json:"issuer" tf:"issuer,omitempty"`

	// +kubebuilder:validation:Required
	Tenant *string `json:"tenant" tf:"tenant,omitempty"`
}

type ClientRevokedCertificateObservation struct {
}

type ClientRevokedCertificateParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Thumbprint *string `json:"thumbprint" tf:"thumbprint,omitempty"`
}

type ClientRootCertificateObservation struct {
}

type ClientRootCertificateParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	PublicCertData *string `json:"publicCertData" tf:"public_cert_data,omitempty"`
}

type RadiusClientRootCertificateObservation struct {
}

type RadiusClientRootCertificateParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Thumbprint *string `json:"thumbprint" tf:"thumbprint,omitempty"`
}

type RadiusObservation struct {
}

type RadiusParameters struct {

	// +kubebuilder:validation:Optional
	ClientRootCertificate []RadiusClientRootCertificateParameters `json:"clientRootCertificate,omitempty" tf:"client_root_certificate,omitempty"`

	// +kubebuilder:validation:Optional
	Server []ServerParameters `json:"server,omitempty" tf:"server,omitempty"`

	// +kubebuilder:validation:Required
	ServerRootCertificate []ServerRootCertificateParameters `json:"serverRootCertificate" tf:"server_root_certificate,omitempty"`
}

type RadiusServerClientRootCertificateObservation struct {
}

type RadiusServerClientRootCertificateParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Thumbprint *string `json:"thumbprint" tf:"thumbprint,omitempty"`
}

type RadiusServerObservation struct {
}

type RadiusServerParameters struct {

	// +kubebuilder:validation:Required
	Address *string `json:"address" tf:"address,omitempty"`

	// +kubebuilder:validation:Optional
	ClientRootCertificate []RadiusServerClientRootCertificateParameters `json:"clientRootCertificate,omitempty" tf:"client_root_certificate,omitempty"`

	// +kubebuilder:validation:Required
	SecretSecretRef v1.SecretKeySelector `json:"secretSecretRef" tf:"-"`

	// +kubebuilder:validation:Required
	ServerRootCertificate []RadiusServerServerRootCertificateParameters `json:"serverRootCertificate" tf:"server_root_certificate,omitempty"`
}

type RadiusServerServerRootCertificateObservation struct {
}

type RadiusServerServerRootCertificateParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	PublicCertData *string `json:"publicCertData" tf:"public_cert_data,omitempty"`
}

type ServerObservation struct {
}

type ServerParameters struct {

	// +kubebuilder:validation:Required
	Address *string `json:"address" tf:"address,omitempty"`

	// +kubebuilder:validation:Required
	Score *int64 `json:"score" tf:"score,omitempty"`

	// +kubebuilder:validation:Required
	SecretSecretRef v1.SecretKeySelector `json:"secretSecretRef" tf:"-"`
}

type ServerRootCertificateObservation struct {
}

type ServerRootCertificateParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	PublicCertData *string `json:"publicCertData" tf:"public_cert_data,omitempty"`
}

type VPNServerConfigurationIpsecPolicyObservation struct {
}

type VPNServerConfigurationIpsecPolicyParameters struct {

	// +kubebuilder:validation:Required
	DhGroup *string `json:"dhGroup" tf:"dh_group,omitempty"`

	// +kubebuilder:validation:Required
	IkeEncryption *string `json:"ikeEncryption" tf:"ike_encryption,omitempty"`

	// +kubebuilder:validation:Required
	IkeIntegrity *string `json:"ikeIntegrity" tf:"ike_integrity,omitempty"`

	// +kubebuilder:validation:Required
	IpsecEncryption *string `json:"ipsecEncryption" tf:"ipsec_encryption,omitempty"`

	// +kubebuilder:validation:Required
	IpsecIntegrity *string `json:"ipsecIntegrity" tf:"ipsec_integrity,omitempty"`

	// +kubebuilder:validation:Required
	PfsGroup *string `json:"pfsGroup" tf:"pfs_group,omitempty"`

	// +kubebuilder:validation:Required
	SaDataSizeKilobytes *int64 `json:"saDataSizeKilobytes" tf:"sa_data_size_kilobytes,omitempty"`

	// +kubebuilder:validation:Required
	SaLifetimeSeconds *int64 `json:"saLifetimeSeconds" tf:"sa_lifetime_seconds,omitempty"`
}

type VPNServerConfigurationObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type VPNServerConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	AzureActiveDirectoryAuthentication []AzureActiveDirectoryAuthenticationParameters `json:"azureActiveDirectoryAuthentication,omitempty" tf:"azure_active_directory_authentication,omitempty"`

	// +kubebuilder:validation:Optional
	ClientRevokedCertificate []ClientRevokedCertificateParameters `json:"clientRevokedCertificate,omitempty" tf:"client_revoked_certificate,omitempty"`

	// +kubebuilder:validation:Optional
	ClientRootCertificate []ClientRootCertificateParameters `json:"clientRootCertificate,omitempty" tf:"client_root_certificate,omitempty"`

	// +kubebuilder:validation:Optional
	IpsecPolicy []VPNServerConfigurationIpsecPolicyParameters `json:"ipsecPolicy,omitempty" tf:"ipsec_policy,omitempty"`

	// +kubebuilder:validation:Required
	Location *string `json:"location" tf:"location,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Radius []RadiusParameters `json:"radius,omitempty" tf:"radius,omitempty"`

	// +kubebuilder:validation:Optional
	RadiusServer []RadiusServerParameters `json:"radiusServer,omitempty" tf:"radius_server,omitempty"`

	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-jet-azure/apis/azure2/v1alpha2.ResourceGroup
	// +kubebuilder:validation:Optional
	ResourceGroupName *string `json:"resourceGroupName,omitempty" tf:"resource_group_name,omitempty"`

	// +kubebuilder:validation:Optional
	ResourceGroupNameRef *v1.Reference `json:"resourceGroupNameRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ResourceGroupNameSelector *v1.Selector `json:"resourceGroupNameSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// +kubebuilder:validation:Required
	VPNAuthenticationTypes []*string `json:"vpnAuthenticationTypes" tf:"vpn_authentication_types,omitempty"`

	// +kubebuilder:validation:Optional
	VPNProtocols []*string `json:"vpnProtocols,omitempty" tf:"vpn_protocols,omitempty"`
}

// VPNServerConfigurationSpec defines the desired state of VPNServerConfiguration
type VPNServerConfigurationSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     VPNServerConfigurationParameters `json:"forProvider"`
}

// VPNServerConfigurationStatus defines the observed state of VPNServerConfiguration.
type VPNServerConfigurationStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        VPNServerConfigurationObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// VPNServerConfiguration is the Schema for the VPNServerConfigurations API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,azurejet}
type VPNServerConfiguration struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              VPNServerConfigurationSpec   `json:"spec"`
	Status            VPNServerConfigurationStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// VPNServerConfigurationList contains a list of VPNServerConfigurations
type VPNServerConfigurationList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []VPNServerConfiguration `json:"items"`
}

// Repository type metadata.
var (
	VPNServerConfiguration_Kind             = "VPNServerConfiguration"
	VPNServerConfiguration_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: VPNServerConfiguration_Kind}.String()
	VPNServerConfiguration_KindAPIVersion   = VPNServerConfiguration_Kind + "." + CRDGroupVersion.String()
	VPNServerConfiguration_GroupVersionKind = CRDGroupVersion.WithKind(VPNServerConfiguration_Kind)
)

func init() {
	SchemeBuilder.Register(&VPNServerConfiguration{}, &VPNServerConfigurationList{})
}
