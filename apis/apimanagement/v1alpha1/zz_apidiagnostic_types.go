/*
Copyright 2020 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type APIDiagnosticObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type APIDiagnosticParameters struct {

	// +kubebuilder:validation:Required
	APIManagementLoggerID *string `json:"apiManagementLoggerId" tf:"api_management_logger_id,omitempty"`

	// +kubebuilder:validation:Required
	APIManagementName *string `json:"apiManagementName" tf:"api_management_name,omitempty"`

	// +kubebuilder:validation:Required
	APIName *string `json:"apiName" tf:"api_name,omitempty"`

	// +kubebuilder:validation:Optional
	AlwaysLogErrors *bool `json:"alwaysLogErrors,omitempty" tf:"always_log_errors,omitempty"`

	// +kubebuilder:validation:Optional
	BackendRequest []BackendRequestParameters `json:"backendRequest,omitempty" tf:"backend_request,omitempty"`

	// +kubebuilder:validation:Optional
	BackendResponse []BackendResponseParameters `json:"backendResponse,omitempty" tf:"backend_response,omitempty"`

	// +kubebuilder:validation:Optional
	FrontendRequest []FrontendRequestParameters `json:"frontendRequest,omitempty" tf:"frontend_request,omitempty"`

	// +kubebuilder:validation:Optional
	FrontendResponse []FrontendResponseParameters `json:"frontendResponse,omitempty" tf:"frontend_response,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPCorrelationProtocol *string `json:"httpCorrelationProtocol,omitempty" tf:"http_correlation_protocol,omitempty"`

	// +kubebuilder:validation:Required
	Identifier *string `json:"identifier" tf:"identifier,omitempty"`

	// +kubebuilder:validation:Optional
	LogClientIP *bool `json:"logClientIp,omitempty" tf:"log_client_ip,omitempty"`

	// +kubebuilder:validation:Optional
	OperationNameFormat *string `json:"operationNameFormat,omitempty" tf:"operation_name_format,omitempty"`

	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-jet-azure/apis/azure2/v1alpha2.ResourceGroup
	// +kubebuilder:validation:Optional
	ResourceGroupName *string `json:"resourceGroupName,omitempty" tf:"resource_group_name,omitempty"`

	// +kubebuilder:validation:Optional
	ResourceGroupNameRef *v1.Reference `json:"resourceGroupNameRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ResourceGroupNameSelector *v1.Selector `json:"resourceGroupNameSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	SamplingPercentage *float64 `json:"samplingPercentage,omitempty" tf:"sampling_percentage,omitempty"`

	// +kubebuilder:validation:Optional
	Verbosity *string `json:"verbosity,omitempty" tf:"verbosity,omitempty"`
}

type BackendRequestObservation struct {
}

type BackendRequestParameters struct {

	// +kubebuilder:validation:Optional
	BodyBytes *int64 `json:"bodyBytes,omitempty" tf:"body_bytes,omitempty"`

	// +kubebuilder:validation:Optional
	DataMasking []DataMaskingParameters `json:"dataMasking,omitempty" tf:"data_masking,omitempty"`

	// +kubebuilder:validation:Optional
	HeadersToLog []*string `json:"headersToLog,omitempty" tf:"headers_to_log,omitempty"`
}

type BackendResponseDataMaskingObservation struct {
}

type BackendResponseDataMaskingParameters struct {

	// +kubebuilder:validation:Optional
	Headers []DataMaskingHeadersParameters `json:"headers,omitempty" tf:"headers,omitempty"`

	// +kubebuilder:validation:Optional
	QueryParams []DataMaskingQueryParamsParameters `json:"queryParams,omitempty" tf:"query_params,omitempty"`
}

type BackendResponseObservation struct {
}

type BackendResponseParameters struct {

	// +kubebuilder:validation:Optional
	BodyBytes *int64 `json:"bodyBytes,omitempty" tf:"body_bytes,omitempty"`

	// +kubebuilder:validation:Optional
	DataMasking []BackendResponseDataMaskingParameters `json:"dataMasking,omitempty" tf:"data_masking,omitempty"`

	// +kubebuilder:validation:Optional
	HeadersToLog []*string `json:"headersToLog,omitempty" tf:"headers_to_log,omitempty"`
}

type DataMaskingHeadersObservation struct {
}

type DataMaskingHeadersParameters struct {

	// +kubebuilder:validation:Required
	Mode *string `json:"mode" tf:"mode,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type DataMaskingObservation struct {
}

type DataMaskingParameters struct {

	// +kubebuilder:validation:Optional
	Headers []HeadersParameters `json:"headers,omitempty" tf:"headers,omitempty"`

	// +kubebuilder:validation:Optional
	QueryParams []QueryParamsParameters `json:"queryParams,omitempty" tf:"query_params,omitempty"`
}

type DataMaskingQueryParamsObservation struct {
}

type DataMaskingQueryParamsParameters struct {

	// +kubebuilder:validation:Required
	Mode *string `json:"mode" tf:"mode,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type FrontendRequestDataMaskingHeadersObservation struct {
}

type FrontendRequestDataMaskingHeadersParameters struct {

	// +kubebuilder:validation:Required
	Mode *string `json:"mode" tf:"mode,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type FrontendRequestDataMaskingObservation struct {
}

type FrontendRequestDataMaskingParameters struct {

	// +kubebuilder:validation:Optional
	Headers []FrontendRequestDataMaskingHeadersParameters `json:"headers,omitempty" tf:"headers,omitempty"`

	// +kubebuilder:validation:Optional
	QueryParams []FrontendRequestDataMaskingQueryParamsParameters `json:"queryParams,omitempty" tf:"query_params,omitempty"`
}

type FrontendRequestDataMaskingQueryParamsObservation struct {
}

type FrontendRequestDataMaskingQueryParamsParameters struct {

	// +kubebuilder:validation:Required
	Mode *string `json:"mode" tf:"mode,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type FrontendRequestObservation struct {
}

type FrontendRequestParameters struct {

	// +kubebuilder:validation:Optional
	BodyBytes *int64 `json:"bodyBytes,omitempty" tf:"body_bytes,omitempty"`

	// +kubebuilder:validation:Optional
	DataMasking []FrontendRequestDataMaskingParameters `json:"dataMasking,omitempty" tf:"data_masking,omitempty"`

	// +kubebuilder:validation:Optional
	HeadersToLog []*string `json:"headersToLog,omitempty" tf:"headers_to_log,omitempty"`
}

type FrontendResponseDataMaskingHeadersObservation struct {
}

type FrontendResponseDataMaskingHeadersParameters struct {

	// +kubebuilder:validation:Required
	Mode *string `json:"mode" tf:"mode,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type FrontendResponseDataMaskingObservation struct {
}

type FrontendResponseDataMaskingParameters struct {

	// +kubebuilder:validation:Optional
	Headers []FrontendResponseDataMaskingHeadersParameters `json:"headers,omitempty" tf:"headers,omitempty"`

	// +kubebuilder:validation:Optional
	QueryParams []FrontendResponseDataMaskingQueryParamsParameters `json:"queryParams,omitempty" tf:"query_params,omitempty"`
}

type FrontendResponseDataMaskingQueryParamsObservation struct {
}

type FrontendResponseDataMaskingQueryParamsParameters struct {

	// +kubebuilder:validation:Required
	Mode *string `json:"mode" tf:"mode,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type FrontendResponseObservation struct {
}

type FrontendResponseParameters struct {

	// +kubebuilder:validation:Optional
	BodyBytes *int64 `json:"bodyBytes,omitempty" tf:"body_bytes,omitempty"`

	// +kubebuilder:validation:Optional
	DataMasking []FrontendResponseDataMaskingParameters `json:"dataMasking,omitempty" tf:"data_masking,omitempty"`

	// +kubebuilder:validation:Optional
	HeadersToLog []*string `json:"headersToLog,omitempty" tf:"headers_to_log,omitempty"`
}

type HeadersObservation struct {
}

type HeadersParameters struct {

	// +kubebuilder:validation:Required
	Mode *string `json:"mode" tf:"mode,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type QueryParamsObservation struct {
}

type QueryParamsParameters struct {

	// +kubebuilder:validation:Required
	Mode *string `json:"mode" tf:"mode,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

// APIDiagnosticSpec defines the desired state of APIDiagnostic
type APIDiagnosticSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     APIDiagnosticParameters `json:"forProvider"`
}

// APIDiagnosticStatus defines the observed state of APIDiagnostic.
type APIDiagnosticStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        APIDiagnosticObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// APIDiagnostic is the Schema for the APIDiagnostics API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,azurejet}
type APIDiagnostic struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              APIDiagnosticSpec   `json:"spec"`
	Status            APIDiagnosticStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// APIDiagnosticList contains a list of APIDiagnostics
type APIDiagnosticList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []APIDiagnostic `json:"items"`
}

// Repository type metadata.
var (
	APIDiagnostic_Kind             = "APIDiagnostic"
	APIDiagnostic_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: APIDiagnostic_Kind}.String()
	APIDiagnostic_KindAPIVersion   = APIDiagnostic_Kind + "." + CRDGroupVersion.String()
	APIDiagnostic_GroupVersionKind = CRDGroupVersion.WithKind(APIDiagnostic_Kind)
)

func init() {
	SchemeBuilder.Register(&APIDiagnostic{}, &APIDiagnosticList{})
}
