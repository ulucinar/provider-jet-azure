/*
Copyright 2020 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

type AccessPolicyObservation struct {
}

type AccessPolicyParameters struct {

	// +kubebuilder:validation:Optional
	ApplicationID *string `json:"applicationId,omitempty" tf:"application_id"`

	// +kubebuilder:validation:Optional
	CertificatePermissions []string `json:"certificatePermissions,omitempty" tf:"certificate_permissions"`

	// +kubebuilder:validation:Optional
	KeyPermissions []string `json:"keyPermissions,omitempty" tf:"key_permissions"`

	// +kubebuilder:validation:Required
	ObjectID string `json:"objectId" tf:"object_id"`

	// +kubebuilder:validation:Optional
	SecretPermissions []string `json:"secretPermissions,omitempty" tf:"secret_permissions"`

	// +kubebuilder:validation:Optional
	StoragePermissions []string `json:"storagePermissions,omitempty" tf:"storage_permissions"`

	// +kubebuilder:validation:Required
	TenantID string `json:"tenantId" tf:"tenant_id"`
}

type ContactObservation struct {
}

type ContactParameters struct {

	// +kubebuilder:validation:Required
	Email string `json:"email" tf:"email"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name"`

	// +kubebuilder:validation:Optional
	Phone *string `json:"phone,omitempty" tf:"phone"`
}

type KeyVaultObservation struct {
	VaultURI string `json:"vaultUri,omitempty" tf:"vault_uri"`
}

type KeyVaultParameters struct {

	// +kubebuilder:validation:Optional
	AccessPolicy []AccessPolicyParameters `json:"accessPolicy,omitempty" tf:"access_policy"`

	// +kubebuilder:validation:Optional
	Contact []ContactParameters `json:"contact,omitempty" tf:"contact"`

	// +kubebuilder:validation:Optional
	EnableRbacAuthorization *bool `json:"enableRbacAuthorization,omitempty" tf:"enable_rbac_authorization"`

	// +kubebuilder:validation:Optional
	EnabledForDeployment *bool `json:"enabledForDeployment,omitempty" tf:"enabled_for_deployment"`

	// +kubebuilder:validation:Optional
	EnabledForDiskEncryption *bool `json:"enabledForDiskEncryption,omitempty" tf:"enabled_for_disk_encryption"`

	// +kubebuilder:validation:Optional
	EnabledForTemplateDeployment *bool `json:"enabledForTemplateDeployment,omitempty" tf:"enabled_for_template_deployment"`

	// +kubebuilder:validation:Required
	Location string `json:"location" tf:"location"`

	// +kubebuilder:validation:Required
	Name string `json:"name" tf:"name"`

	// +kubebuilder:validation:Optional
	NetworkAcls []NetworkAclsParameters `json:"networkAcls,omitempty" tf:"network_acls"`

	// +kubebuilder:validation:Optional
	PurgeProtectionEnabled *bool `json:"purgeProtectionEnabled,omitempty" tf:"purge_protection_enabled"`

	// +kubebuilder:validation:Required
	ResourceGroupName string `json:"resourceGroupName" tf:"resource_group_name"`

	// +kubebuilder:validation:Required
	SkuName string `json:"skuName" tf:"sku_name"`

	// +kubebuilder:validation:Optional
	SoftDeleteEnabled *bool `json:"softDeleteEnabled,omitempty" tf:"soft_delete_enabled"`

	// +kubebuilder:validation:Optional
	SoftDeleteRetentionDays *int64 `json:"softDeleteRetentionDays,omitempty" tf:"soft_delete_retention_days"`

	// +kubebuilder:validation:Optional
	Tags map[string]string `json:"tags,omitempty" tf:"tags"`

	// +kubebuilder:validation:Required
	TenantID string `json:"tenantId" tf:"tenant_id"`
}

type NetworkAclsObservation struct {
}

type NetworkAclsParameters struct {

	// +kubebuilder:validation:Required
	Bypass string `json:"bypass" tf:"bypass"`

	// +kubebuilder:validation:Required
	DefaultAction string `json:"defaultAction" tf:"default_action"`

	// +kubebuilder:validation:Optional
	IPRules []string `json:"ipRules,omitempty" tf:"ip_rules"`

	// +kubebuilder:validation:Optional
	VirtualNetworkSubnetIds []string `json:"virtualNetworkSubnetIds,omitempty" tf:"virtual_network_subnet_ids"`
}

// KeyVaultSpec defines the desired state of KeyVault
type KeyVaultSpec struct {
	xpv1.ResourceSpec `json:",inline"`
	ForProvider       KeyVaultParameters `json:"forProvider"`
}

// KeyVaultStatus defines the observed state of KeyVault.
type KeyVaultStatus struct {
	xpv1.ResourceStatus `json:",inline"`
	AtProvider          KeyVaultObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// KeyVault is the Schema for the KeyVaults API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,azure}
type KeyVault struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              KeyVaultSpec   `json:"spec"`
	Status            KeyVaultStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// KeyVaultList contains a list of KeyVaults
type KeyVaultList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []KeyVault `json:"items"`
}

// Repository type metadata.
var (
	KeyVaultKind             = "KeyVault"
	KeyVaultGroupKind        = schema.GroupKind{Group: Group, Kind: KeyVaultKind}.String()
	KeyVaultKindAPIVersion   = KeyVaultKind + "." + GroupVersion.String()
	KeyVaultGroupVersionKind = GroupVersion.WithKind(KeyVaultKind)
)

func init() {
	SchemeBuilder.Register(&KeyVault{}, &KeyVaultList{})
}
