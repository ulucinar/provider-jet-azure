/*
Copyright 2020 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

type ActionObservation struct {
}

type ActionParameters struct {

	// +kubebuilder:validation:Required
	ActionType string `json:"actionType" tf:"action_type"`
}

type CertificateAttributeObservation struct {
	Created string `json:"created,omitempty" tf:"created"`

	Enabled bool `json:"enabled,omitempty" tf:"enabled"`

	Expires string `json:"expires,omitempty" tf:"expires"`

	NotBefore string `json:"notBefore,omitempty" tf:"not_before"`

	RecoveryLevel string `json:"recoveryLevel,omitempty" tf:"recovery_level"`

	Updated string `json:"updated,omitempty" tf:"updated"`
}

type CertificateAttributeParameters struct {
}

type CertificateObservation struct {
}

type CertificateParameters struct {

	// +kubebuilder:validation:Required
	Contents string `json:"contents" tf:"contents"`

	// +kubebuilder:validation:Optional
	Password *string `json:"password,omitempty" tf:"password"`
}

type CertificatePolicyObservation struct {
}

type CertificatePolicyParameters struct {

	// +kubebuilder:validation:Required
	IssuerParameters []IssuerParametersParameters `json:"issuerParameters" tf:"issuer_parameters"`

	// +kubebuilder:validation:Required
	KeyProperties []KeyPropertiesParameters `json:"keyProperties" tf:"key_properties"`

	// +kubebuilder:validation:Optional
	LifetimeAction []LifetimeActionParameters `json:"lifetimeAction,omitempty" tf:"lifetime_action"`

	// +kubebuilder:validation:Required
	SecretProperties []SecretPropertiesParameters `json:"secretProperties" tf:"secret_properties"`

	// +kubebuilder:validation:Optional
	X509CertificateProperties []X509CertificatePropertiesParameters `json:"x509CertificateProperties,omitempty" tf:"x509_certificate_properties"`
}

type IssuerParametersObservation struct {
}

type IssuerParametersParameters struct {

	// +kubebuilder:validation:Required
	Name string `json:"name" tf:"name"`
}

type KeyPropertiesObservation struct {
}

type KeyPropertiesParameters struct {

	// +kubebuilder:validation:Optional
	Curve *string `json:"curve,omitempty" tf:"curve"`

	// +kubebuilder:validation:Required
	Exportable bool `json:"exportable" tf:"exportable"`

	// +kubebuilder:validation:Optional
	KeySize *int64 `json:"keySize,omitempty" tf:"key_size"`

	// +kubebuilder:validation:Required
	KeyType string `json:"keyType" tf:"key_type"`

	// +kubebuilder:validation:Required
	ReuseKey bool `json:"reuseKey" tf:"reuse_key"`
}

type KeyVaultCertificateObservation struct {
	CertificateAttribute []CertificateAttributeObservation `json:"certificateAttribute,omitempty" tf:"certificate_attribute"`

	CertificateData string `json:"certificateData,omitempty" tf:"certificate_data"`

	CertificateDataBase64 string `json:"certificateDataBase64,omitempty" tf:"certificate_data_base64"`

	SecretID string `json:"secretId,omitempty" tf:"secret_id"`

	Thumbprint string `json:"thumbprint,omitempty" tf:"thumbprint"`

	Version string `json:"version,omitempty" tf:"version"`
}

type KeyVaultCertificateParameters struct {

	// +kubebuilder:validation:Optional
	Certificate []CertificateParameters `json:"certificate,omitempty" tf:"certificate"`

	// +kubebuilder:validation:Required
	CertificatePolicy []CertificatePolicyParameters `json:"certificatePolicy" tf:"certificate_policy"`

	// +kubebuilder:validation:Required
	KeyVaultID string `json:"keyVaultId" tf:"key_vault_id"`

	// +kubebuilder:validation:Required
	Name string `json:"name" tf:"name"`

	// +kubebuilder:validation:Optional
	Tags map[string]string `json:"tags,omitempty" tf:"tags"`
}

type LifetimeActionObservation struct {
}

type LifetimeActionParameters struct {

	// +kubebuilder:validation:Required
	Action []ActionParameters `json:"action" tf:"action"`

	// +kubebuilder:validation:Required
	Trigger []TriggerParameters `json:"trigger" tf:"trigger"`
}

type SecretPropertiesObservation struct {
}

type SecretPropertiesParameters struct {

	// +kubebuilder:validation:Required
	ContentType string `json:"contentType" tf:"content_type"`
}

type SubjectAlternativeNamesObservation struct {
}

type SubjectAlternativeNamesParameters struct {

	// +kubebuilder:validation:Optional
	DNSNames []string `json:"dnsNames,omitempty" tf:"dns_names"`

	// +kubebuilder:validation:Optional
	Emails []string `json:"emails,omitempty" tf:"emails"`

	// +kubebuilder:validation:Optional
	Upns []string `json:"upns,omitempty" tf:"upns"`
}

type TriggerObservation struct {
}

type TriggerParameters struct {

	// +kubebuilder:validation:Optional
	DaysBeforeExpiry *int64 `json:"daysBeforeExpiry,omitempty" tf:"days_before_expiry"`

	// +kubebuilder:validation:Optional
	LifetimePercentage *int64 `json:"lifetimePercentage,omitempty" tf:"lifetime_percentage"`
}

type X509CertificatePropertiesObservation struct {
}

type X509CertificatePropertiesParameters struct {

	// +kubebuilder:validation:Optional
	ExtendedKeyUsage []string `json:"extendedKeyUsage,omitempty" tf:"extended_key_usage"`

	// +kubebuilder:validation:Required
	KeyUsage []string `json:"keyUsage" tf:"key_usage"`

	// +kubebuilder:validation:Required
	Subject string `json:"subject" tf:"subject"`

	// +kubebuilder:validation:Optional
	SubjectAlternativeNames []SubjectAlternativeNamesParameters `json:"subjectAlternativeNames,omitempty" tf:"subject_alternative_names"`

	// +kubebuilder:validation:Required
	ValidityInMonths int64 `json:"validityInMonths" tf:"validity_in_months"`
}

// KeyVaultCertificateSpec defines the desired state of KeyVaultCertificate
type KeyVaultCertificateSpec struct {
	xpv1.ResourceSpec `json:",inline"`
	ForProvider       KeyVaultCertificateParameters `json:"forProvider"`
}

// KeyVaultCertificateStatus defines the observed state of KeyVaultCertificate.
type KeyVaultCertificateStatus struct {
	xpv1.ResourceStatus `json:",inline"`
	AtProvider          KeyVaultCertificateObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// KeyVaultCertificate is the Schema for the KeyVaultCertificates API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,azure}
type KeyVaultCertificate struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              KeyVaultCertificateSpec   `json:"spec"`
	Status            KeyVaultCertificateStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// KeyVaultCertificateList contains a list of KeyVaultCertificates
type KeyVaultCertificateList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []KeyVaultCertificate `json:"items"`
}

// Repository type metadata.
var (
	KeyVaultCertificateKind             = "KeyVaultCertificate"
	KeyVaultCertificateGroupKind        = schema.GroupKind{Group: Group, Kind: KeyVaultCertificateKind}.String()
	KeyVaultCertificateKindAPIVersion   = KeyVaultCertificateKind + "." + GroupVersion.String()
	KeyVaultCertificateGroupVersionKind = GroupVersion.WithKind(KeyVaultCertificateKind)
)

func init() {
	SchemeBuilder.Register(&KeyVaultCertificate{}, &KeyVaultCertificateList{})
}
