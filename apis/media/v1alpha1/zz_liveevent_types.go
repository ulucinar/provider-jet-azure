/*
Copyright 2020 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type CrossSiteAccessPolicyObservation struct {
}

type CrossSiteAccessPolicyParameters struct {

	// +kubebuilder:validation:Optional
	ClientAccessPolicy *string `json:"clientAccessPolicy,omitempty" tf:"client_access_policy,omitempty"`

	// +kubebuilder:validation:Optional
	CrossDomainPolicy *string `json:"crossDomainPolicy,omitempty" tf:"cross_domain_policy,omitempty"`
}

type EncodingObservation struct {
}

type EncodingParameters struct {

	// +kubebuilder:validation:Optional
	KeyFrameInterval *string `json:"keyFrameInterval,omitempty" tf:"key_frame_interval,omitempty"`

	// +kubebuilder:validation:Optional
	PresetName *string `json:"presetName,omitempty" tf:"preset_name,omitempty"`

	// +kubebuilder:validation:Optional
	StretchMode *string `json:"stretchMode,omitempty" tf:"stretch_mode,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type EndpointObservation struct {
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	URL *string `json:"url,omitempty" tf:"url,omitempty"`
}

type EndpointParameters struct {
}

type IPAccessControlAllowObservation struct {
}

type IPAccessControlAllowParameters struct {

	// +kubebuilder:validation:Optional
	Address *string `json:"address,omitempty" tf:"address,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetPrefixLength *int64 `json:"subnetPrefixLength,omitempty" tf:"subnet_prefix_length,omitempty"`
}

type InputObservation struct {
	Endpoint []EndpointObservation `json:"endpoint,omitempty" tf:"endpoint,omitempty"`
}

type InputParameters struct {

	// +kubebuilder:validation:Optional
	AccessToken *string `json:"accessToken,omitempty" tf:"access_token,omitempty"`

	// +kubebuilder:validation:Optional
	IPAccessControlAllow []IPAccessControlAllowParameters `json:"ipAccessControlAllow,omitempty" tf:"ip_access_control_allow,omitempty"`

	// +kubebuilder:validation:Optional
	KeyFrameIntervalDuration *string `json:"keyFrameIntervalDuration,omitempty" tf:"key_frame_interval_duration,omitempty"`

	// +kubebuilder:validation:Optional
	StreamingProtocol *string `json:"streamingProtocol,omitempty" tf:"streaming_protocol,omitempty"`
}

type LiveEventObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type LiveEventParameters struct {

	// +kubebuilder:validation:Optional
	AutoStartEnabled *bool `json:"autoStartEnabled,omitempty" tf:"auto_start_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	CrossSiteAccessPolicy []CrossSiteAccessPolicyParameters `json:"crossSiteAccessPolicy,omitempty" tf:"cross_site_access_policy,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	Encoding []EncodingParameters `json:"encoding,omitempty" tf:"encoding,omitempty"`

	// +kubebuilder:validation:Optional
	HostNamePrefix *string `json:"hostnamePrefix,omitempty" tf:"hostname_prefix,omitempty"`

	// +kubebuilder:validation:Required
	Input []InputParameters `json:"input" tf:"input,omitempty"`

	// +kubebuilder:validation:Required
	Location *string `json:"location" tf:"location,omitempty"`

	// +kubebuilder:validation:Required
	MediaServicesAccountName *string `json:"mediaServicesAccountName" tf:"media_services_account_name,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Preview []PreviewParameters `json:"preview,omitempty" tf:"preview,omitempty"`

	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-jet-azure/apis/azure2/v1alpha2.ResourceGroup
	// +kubebuilder:validation:Optional
	ResourceGroupName *string `json:"resourceGroupName,omitempty" tf:"resource_group_name,omitempty"`

	// +kubebuilder:validation:Optional
	ResourceGroupNameRef *v1.Reference `json:"resourceGroupNameRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ResourceGroupNameSelector *v1.Selector `json:"resourceGroupNameSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// +kubebuilder:validation:Optional
	TranscriptionLanguages []*string `json:"transcriptionLanguages,omitempty" tf:"transcription_languages,omitempty"`

	// +kubebuilder:validation:Optional
	UseStaticHostName *bool `json:"useStaticHostname,omitempty" tf:"use_static_hostname,omitempty"`
}

type PreviewEndpointObservation struct {
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	URL *string `json:"url,omitempty" tf:"url,omitempty"`
}

type PreviewEndpointParameters struct {
}

type PreviewIPAccessControlAllowObservation struct {
}

type PreviewIPAccessControlAllowParameters struct {

	// +kubebuilder:validation:Optional
	Address *string `json:"address,omitempty" tf:"address,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetPrefixLength *int64 `json:"subnetPrefixLength,omitempty" tf:"subnet_prefix_length,omitempty"`
}

type PreviewObservation struct {
	Endpoint []PreviewEndpointObservation `json:"endpoint,omitempty" tf:"endpoint,omitempty"`
}

type PreviewParameters struct {

	// +kubebuilder:validation:Optional
	AlternativeMediaID *string `json:"alternativeMediaId,omitempty" tf:"alternative_media_id,omitempty"`

	// +kubebuilder:validation:Optional
	IPAccessControlAllow []PreviewIPAccessControlAllowParameters `json:"ipAccessControlAllow,omitempty" tf:"ip_access_control_allow,omitempty"`

	// +kubebuilder:validation:Optional
	PreviewLocator *string `json:"previewLocator,omitempty" tf:"preview_locator,omitempty"`

	// +kubebuilder:validation:Optional
	StreamingPolicyName *string `json:"streamingPolicyName,omitempty" tf:"streaming_policy_name,omitempty"`
}

// LiveEventSpec defines the desired state of LiveEvent
type LiveEventSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     LiveEventParameters `json:"forProvider"`
}

// LiveEventStatus defines the observed state of LiveEvent.
type LiveEventStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        LiveEventObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// LiveEvent is the Schema for the LiveEvents API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,azurejet}
type LiveEvent struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              LiveEventSpec   `json:"spec"`
	Status            LiveEventStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// LiveEventList contains a list of LiveEvents
type LiveEventList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []LiveEvent `json:"items"`
}

// Repository type metadata.
var (
	LiveEvent_Kind             = "LiveEvent"
	LiveEvent_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: LiveEvent_Kind}.String()
	LiveEvent_KindAPIVersion   = LiveEvent_Kind + "." + CRDGroupVersion.String()
	LiveEvent_GroupVersionKind = CRDGroupVersion.WithKind(LiveEvent_Kind)
)

func init() {
	SchemeBuilder.Register(&LiveEvent{}, &LiveEventList{})
}
