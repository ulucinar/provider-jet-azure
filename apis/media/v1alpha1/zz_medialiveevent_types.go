/*
Copyright 2020 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

type CrossSiteAccessPolicyObservation struct {
}

type CrossSiteAccessPolicyParameters struct {

	// +kubebuilder:validation:Optional
	ClientAccessPolicy *string `json:"clientAccessPolicy,omitempty" tf:"client_access_policy"`

	// +kubebuilder:validation:Optional
	CrossDomainPolicy *string `json:"crossDomainPolicy,omitempty" tf:"cross_domain_policy"`
}

type EncodingObservation struct {
}

type EncodingParameters struct {

	// +kubebuilder:validation:Optional
	KeyFrameInterval *string `json:"keyFrameInterval,omitempty" tf:"key_frame_interval"`

	// +kubebuilder:validation:Optional
	PresetName *string `json:"presetName,omitempty" tf:"preset_name"`

	// +kubebuilder:validation:Optional
	StretchMode *string `json:"stretchMode,omitempty" tf:"stretch_mode"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type"`
}

type EndpointObservation struct {
	Protocol string `json:"protocol,omitempty" tf:"protocol"`

	URL string `json:"url,omitempty" tf:"url"`
}

type EndpointParameters struct {
}

type IPAccessControlAllowObservation struct {
}

type IPAccessControlAllowParameters struct {

	// +kubebuilder:validation:Optional
	Address *string `json:"address,omitempty" tf:"address"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name"`

	// +kubebuilder:validation:Optional
	SubnetPrefixLength *int64 `json:"subnetPrefixLength,omitempty" tf:"subnet_prefix_length"`
}

type InputObservation struct {
	Endpoint []EndpointObservation `json:"endpoint,omitempty" tf:"endpoint"`
}

type InputParameters struct {

	// +kubebuilder:validation:Optional
	AccessToken *string `json:"accessToken,omitempty" tf:"access_token"`

	// +kubebuilder:validation:Optional
	IPAccessControlAllow []IPAccessControlAllowParameters `json:"ipAccessControlAllow,omitempty" tf:"ip_access_control_allow"`

	// +kubebuilder:validation:Optional
	KeyFrameIntervalDuration *string `json:"keyFrameIntervalDuration,omitempty" tf:"key_frame_interval_duration"`

	// +kubebuilder:validation:Optional
	StreamingProtocol *string `json:"streamingProtocol,omitempty" tf:"streaming_protocol"`
}

type MediaLiveEventObservation struct {
}

type MediaLiveEventParameters struct {

	// +kubebuilder:validation:Optional
	AutoStartEnabled *bool `json:"autoStartEnabled,omitempty" tf:"auto_start_enabled"`

	// +kubebuilder:validation:Optional
	CrossSiteAccessPolicy []CrossSiteAccessPolicyParameters `json:"crossSiteAccessPolicy,omitempty" tf:"cross_site_access_policy"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description"`

	// +kubebuilder:validation:Optional
	Encoding []EncodingParameters `json:"encoding,omitempty" tf:"encoding"`

	// +kubebuilder:validation:Optional
	HostnamePrefix *string `json:"hostnamePrefix,omitempty" tf:"hostname_prefix"`

	// +kubebuilder:validation:Required
	Input []InputParameters `json:"input" tf:"input"`

	// +kubebuilder:validation:Required
	Location string `json:"location" tf:"location"`

	// +kubebuilder:validation:Required
	MediaServicesAccountName string `json:"mediaServicesAccountName" tf:"media_services_account_name"`

	// +kubebuilder:validation:Required
	Name string `json:"name" tf:"name"`

	// +kubebuilder:validation:Optional
	Preview []PreviewParameters `json:"preview,omitempty" tf:"preview"`

	// +kubebuilder:validation:Required
	ResourceGroupName string `json:"resourceGroupName" tf:"resource_group_name"`

	// +kubebuilder:validation:Optional
	Tags map[string]string `json:"tags,omitempty" tf:"tags"`

	// +kubebuilder:validation:Optional
	TranscriptionLanguages []string `json:"transcriptionLanguages,omitempty" tf:"transcription_languages"`

	// +kubebuilder:validation:Optional
	UseStaticHostname *bool `json:"useStaticHostname,omitempty" tf:"use_static_hostname"`
}

type PreviewEndpointObservation struct {
	Protocol string `json:"protocol,omitempty" tf:"protocol"`

	URL string `json:"url,omitempty" tf:"url"`
}

type PreviewEndpointParameters struct {
}

type PreviewIPAccessControlAllowObservation struct {
}

type PreviewIPAccessControlAllowParameters struct {

	// +kubebuilder:validation:Optional
	Address *string `json:"address,omitempty" tf:"address"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name"`

	// +kubebuilder:validation:Optional
	SubnetPrefixLength *int64 `json:"subnetPrefixLength,omitempty" tf:"subnet_prefix_length"`
}

type PreviewObservation struct {
	Endpoint []PreviewEndpointObservation `json:"endpoint,omitempty" tf:"endpoint"`
}

type PreviewParameters struct {

	// +kubebuilder:validation:Optional
	AlternativeMediaID *string `json:"alternativeMediaId,omitempty" tf:"alternative_media_id"`

	// +kubebuilder:validation:Optional
	IPAccessControlAllow []PreviewIPAccessControlAllowParameters `json:"ipAccessControlAllow,omitempty" tf:"ip_access_control_allow"`

	// +kubebuilder:validation:Optional
	PreviewLocator *string `json:"previewLocator,omitempty" tf:"preview_locator"`

	// +kubebuilder:validation:Optional
	StreamingPolicyName *string `json:"streamingPolicyName,omitempty" tf:"streaming_policy_name"`
}

// MediaLiveEventSpec defines the desired state of MediaLiveEvent
type MediaLiveEventSpec struct {
	xpv1.ResourceSpec `json:",inline"`
	ForProvider       MediaLiveEventParameters `json:"forProvider"`
}

// MediaLiveEventStatus defines the observed state of MediaLiveEvent.
type MediaLiveEventStatus struct {
	xpv1.ResourceStatus `json:",inline"`
	AtProvider          MediaLiveEventObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// MediaLiveEvent is the Schema for the MediaLiveEvents API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,azure}
type MediaLiveEvent struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              MediaLiveEventSpec   `json:"spec"`
	Status            MediaLiveEventStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// MediaLiveEventList contains a list of MediaLiveEvents
type MediaLiveEventList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []MediaLiveEvent `json:"items"`
}

// Repository type metadata.
var (
	MediaLiveEventKind             = "MediaLiveEvent"
	MediaLiveEventGroupKind        = schema.GroupKind{Group: Group, Kind: MediaLiveEventKind}.String()
	MediaLiveEventKindAPIVersion   = MediaLiveEventKind + "." + GroupVersion.String()
	MediaLiveEventGroupVersionKind = GroupVersion.WithKind(MediaLiveEventKind)
)

func init() {
	SchemeBuilder.Register(&MediaLiveEvent{}, &MediaLiveEventList{})
}
